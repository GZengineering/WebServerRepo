<!DOCTYPE html>
<!-- This code was written by Alex Stout for Goal Zero, LLC private use -->
<html lang='en' style= 'background-color:#666666; padding: 0px 25px 25px'>
<head>
    <title>Parameter: Family</title>
    <table width="100%" style="padding-top: 10px">
        <col width = "49%">
        <col width = "51%">
        <tr>
            <td align="left" valign="bottom">
                <button id="button_refresh_data"></button>
            </td>
            <td valign="bottom">
                <h1 align = 'left'> Parameter: Family  </h1>
            </td>   
        </tr>
    </table>

    <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dojo/resources/dojo.css">
    <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dijit/themes/claro/claro.css">
    <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dojox/grid/resources/claroGrid.css">
        
    <style type="text/css">@import "http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dojox/grid/resources/claroGrid.css";
        #FamilyGrid
        {
            height: 51.4em;
            width: 100%;
        }
        #PreviewGrid 
        {
            height: 46em;
            width: 100%;
        }
        #GroupGridDiv 
        {
            height: 46em;
            width: 100%;
        }
        #FamilyViewerGrid
        {
            height: 51.4em;
            width: 100%;
        }
        .dojoxGridMasterView
        {
            font-size: 8pt;
        }
        .dojoxGridMasterHeader
        {
            font-size: 8pt;
        }
    </style>
    <script src="http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dojo/dojo.js" data-dojo-config="async: true, isDebug: true">
    </script>

    <!-- Dojo Execution -->
    <script>
    require(['dojo/_base/lang', 
        'dojox/grid/DataGrid' , 
        'dojo/data/ItemFileWriteStore' ,
        "dojo/_base/array",
        'dijit/registry',
        'dojo/_base/xhr', 
        'dijit/form/RadioButton',
        'dojox/grid/_CheckBoxSelector',
        "dijit/form/Button",
        'dijit/form/TextBox', 
        'dojo/store/Observable',
        'dojo/store/Memory',
        'dojo/data/ObjectStore',
        'dojo/dom' , 
        'dojo/domReady!'],
      function(lang, DataGrid, ItemFileWriteStore, baseArray, registry, xhr, RadioButton, _CheckBoxSelector, Button, TextBox, Observable, Memory, ObjectStore, dom)
        {
            /*  THIS FLAG NOTIFIES THE SERVER WHETHER THE HTML FOR THIS PAGE HAS ALREADY BEEN LOADED  */
            var has_loaded = false;

            /*  CREATE A DATA STORE TO CONTAIN ALL THE CONTENT OF THE SERVER  */
            var fullDbMemStore = new Memory({data: new Array()});
                fullDbMemStore = Observable(fullDbMemStore);
                var fullDataStore = new ObjectStore({
                    objectStore: fullDbMemStore
                });
            window.fullDbMemStore = fullDbMemStore; //MAKE IT GLOBAL

            /*  FUNCTION TO GET ALL THE DB DATA AND FILL THE DATA STORE  */
            init = function()
            {
                xhr.get(
                {
                    url:'/global',
                    handleAs: 'json',
                    content:
                    {
                        action: 'getAll',
                        loaded: has_loaded = true,
                    },
                    load: function(response)
                    {
                        fullDbMemStore.data = response;
                        BuildGrids();
                    },
                    error: function(error)
                    {
                        var msg = 'There was an error getting the db. Error: ' + error;
                        dom.byId("serverResponse").innerHTML = 'Response: ' + msg;
                        console.log(msg);
                    }
                });
            }


            /*  BUILDS THE GRIDS USING THE COLLECTED AND ORGANIZED DATA  */
            function BuildGrids()
            {
                //QUERY TO GET THE PARAMETERS FROM THE FULL STORE
                var parameters = fullDbMemStore.query({type: "p"});
                var paramStore = new Memory({data: parameters});
                    paramStore = Observable(paramStore);
                    var paramDataStore = new ObjectStore({
                        objectStore: paramStore
                    });

                //GLOBALIZE THE PARAMETER STORE
                window.paramStore = paramStore;
                window.paramDataStore = paramDataStore;
                
                //GET GROUPS AND BUILD THE GROUP GRID
                var groups = GroupGrid.getGroups();
                GroupGrid.buildGrid(groups);

                //GET FAMILIES AND BUILD THE FAMILY GRID
                var families = FamilyGrid.getFamilies();
                FamilyGrid.buildGrid(families);

                //BUILD EMPTY SELECTION/FAMILY VIEWER GRIDS
                PreviewGrid.buildGrid(new Array());
                FamilyViewerGrid.buildGrid(new Array());

                //clear name text field
                dom.byId('txtBox_familyName').value = '';
            }


            /********************************     Group Grid      *********************************/

            //OBJECT TO ASSOCIATE GROUP GRID PROPERTIES AND FUNCTIONS
            var GroupGrid = new Object();

            //GET AND RETURN THE GROUPS FROM THE STORE
            GroupGrid.getGroups = function()
            {
                var groups = fullDbMemStore.query({type: 'pg'});
                return groups;
            }

            //BUILD THE DOJO GRID WITH THE GIVEN ARRAY OF GROUPS
            GroupGrid.buildGrid = function(groups)
            {
                //DEFINE THE LAYOUT
                var layout = [{type: 'dojox.grid._CheckBoxSelector'},[
                  {'name': 'Group', 'field': 'name', 'width': '100%'},
                ]];

                //ALLOCATE THE STORE
                var GroupMemStore = new Memory({data: new Array()}); //set up the store
                GroupMemStore = Observable(GroupMemStore);
                var GroupDataStore = new ObjectStore({
                    objectStore: GroupMemStore
                });
                
                //Fill the store with the retrieved DB data
                for(var i = 0; i < groups.length; i++)
                {
                    GroupMemStore.put(lang.mixin(
                        { id: i }, 
                        groups[i]
                    ));
                }

                //REMOVE FROM THE REGISTRY IF IT EXISTS
                registry.remove('GroupGridDiv');

                /*create a new grid*/
                var grid = new DataGrid({
                    store: GroupDataStore,
                    structure: layout}, 'GroupGridDiv');
                grid.startup(); //RENDER

                //REGISTER THE NOTIFY EVENT TO REFRESH THE GRID
                dojo.connect(GroupMemStore, 'notify', function(){grid._refresh()});
                

                //UPDATE THE GROUP SELECTION AND DISPLAY IT IN THE RESPONSE DIV
                function reportSelection(node)
                {
                    //STORE THE SELECTED ITEMS
                    var groups = this.selection.getSelected();
                    GroupGrid.selected_groups = groups;

                    /*  DISPLAY WHAT'S SELECTED IN THE PROMPT  */
                    if(groups.length < 1)
                        return;

                    var msg = "You have selected " + ((groups.length > 1) ? " ": " ");
                    //FOR EACH PG IN GROUPS, GET THE PG_NAME AND PUT IT IN AN ARRAY 
                    var names = [];
                    for(var i = 0; i < groups.length; i++)
                    {
                        if(!groups[i])
                            return;
                        names.push(groups[i].name);
                    }

                    //UPDATE RESPONSE DIV
                    node.innerHTML = msg + names.join(", ");
                }
                
                //On selection change, call reportSelection() and pass in the response dom
                grid.on("SelectionChanged", 
                    lang.hitch(grid, reportSelection, dom.byId("serverResponse")), true);


                //GLOBALIZE GRID AND STORE
                window.groupGrid = grid;
                window.GroupMemStore = GroupMemStore;
            }


            //GETS AND RETURNS ALL THE PIs OF THE GIVEN PGs
            GroupGrid.getFieldsOfGroups = function(pgs)
            {
                //IF THE GIVEN ARRAY IS EMPTY, RETURN AN EMPTY ARRAY
                if(pgs.length < 1)
                    return new Array();

                //CREATE AN ARRAY TO STORE REALIZED PIs
                var parameters = [];

                //FOR EACH GROUP IN THE GIVEN PGs, MATCH THE PI IDs TO IDs IN THE STORE
                //IF A MATCH IS FOUND, ADD IT TO THE STORE AND MOVE TO THE NEXT PI
                for(var h = 0; h < pgs.length; h++)
                {   
                    //STORE THE CURRENT PG
                    var pg = pgs[h];

                    //IF THE PG IS NULL, BAIL
                    if(!pg)
                        return;

                    for(var i = 0; i < pg.members.length; i++)
                    {
                        var pg_member_id = {}; //OBJECT FOR CURRENT MEMBER ID

                        //IF WE ARE DEALING WITH A FULL PARAMETER OBJECT, GET THE ID OF THE OBJECT
                        //OTHERWISE WE SHOULD BE REFERENCING THE ID OF THE PARAMETER
                        if(pg.members[i]._id)
                            pg_member_id = pg.members[i]._id;
                        else
                            pg_member_id = pg.members[i];                            
                        //FLAGS IF A MATCH IS FOUND
                        var matched = false;
                        for(var j = 0; j < paramStore.data.length; j++)
                        {
                            if(matched)
                                break;
                            //TRY TO MATCH THE CURRENT PI ID TO AN ID IN THE STORE
                            if(pg_member_id == paramStore.data[j]._id)
                            {
                                //IF THERE'S A MATCH, PUSH THE PI OBJECT TO THE ARRAY
                                if(parameters.indexOf(paramStore.data[j]) == -1)
                                {
                                    parameters.push(paramStore.data[j]);
                                    matched = true;
                                }
                            }
                        }
                    }
                }

                //RETURN THE RESULTING ARRAY
                return parameters;
            }

            /********************************      End Group Grid      ********************************/


            /*******************************    BEGIN PREVIEW GRID    ******************************/

            //OBJECT TO ASSOCIATE ALL FUNCTIONS AND PROPERTIES OF THE PREVIEW GRID
            var PreviewGrid = new Object();
            
            /*  BUILD THE GRID GIVEN THE PIs AS A PARAMETER  */
            PreviewGrid.buildGrid = function(pgs)
            {
                /*  DEFINE LAYOUT  */
                var layout = [{type: 'dojox.grid._CheckBoxSelector'},[
                  {'name': 'Group', 'field': 'pg_name', 'width': '15%'},
                  {'name': 'Parameter', 'field': 'p_name', 'width': '15%'},
                  {'name': 'Formula', 'field': 'p_formula', 'width': '40%'},
                  {'name': 'Value', 'field': 'p_value', 'width': '30%', editable: true},
                ]];


                /*  SET UP DATA STORE  */
                var previewMemStore = new Memory({data: new Array(), idProperty: 'p_name'});
                previewMemStore = Observable(previewMemStore);
                var previewDataStore = new ObjectStore({
                    objectStore: previewMemStore
                });
                

                /*  POPULATE THE STORE  */
                for(var i = 0; i < pgs.length; i++)
                {
                    var pg = pgs[i];
                    
                    //GET PIs OF CURRENT PG
                    var pis = pg.members;

                    //DEFINE THE THE ROW FOR THE VIEWER GRID USING THE PI & PG DATA
                    for(var j = 0; j<pis.length; j++)
                    {
                        var row = {};
                        var pi = pis[j];
                        for(var k = 0; k < paramStore.data.length; k++)
                        {
                            if(pi == paramStore.data[k]._id)
                                pi = paramStore.data[k];
                        }
                        if(!pi.members)
                            continue;
                        row.pg = pg;
                        row.pi = pi;
                        row.pg_name = pg.name;
                        row.p_name = pi.name;
                        row.p_formula = pi.members.formula;
                        row.p_value = pi.members.formula;
                        try
                        {
                            previewMemStore.add(row);
                        }
                        catch(e){}
                    }
                }

                for(var i = 0; i < previewMemStore.data.length; i++)
                {
                    var element1 = previewMemStore.data[i];
                    for(var j = 0; j < previewMemStore.data.length; j++)
                    {
                        var element2 = previewMemStore.data[j];
                        if ((element1.pi._id == element2.pi._id) && (element1.pg_name != element2.pg_name))
                            previewMemStore.remove(element2.p_name);
                    }
                }

                var new_data = [];
                for(var i = 0; i < previewMemStore.data.length; i++)
                {
                    var element = previewMemStore.data[i];
                    var v_temp = realizeValue(previewMemStore.data, element.p_formula);
                    if(!v_temp == "")
                    {
                        element.p_value = v_temp;
                        new_data.push(element);
                    }
                }
                for(var i = 0;i < new_data.length; i++)
                {
                    var element = new_data[i];
                    previewMemStore.remove(element.p_name);
                    try
                    {
                        previewMemStore.add(element);
                    }
                    catch(error){console.log(element.p_name + " is already in this store");} 
                }

                // recompute_values(previewMemStore);

                //BUILD THE PREVIEW GRID
                // PreviewGrid.rebuildStore(pgs);


                //REMOVE FROM REGISTRY IF IT EXISTS
                registry.remove('PreviewGrid');


                /*  CREATE THE DOJO GRID AND RENDER IT  */
                var grid = new DataGrid({
                    store: previewDataStore,
                    structure: layout,
                    singleClickEdit: true}, "PreviewGrid");
                grid.startup();


                dojo.connect(grid, "onApplyCellEdit", function(inValue, inRowIndex, inFieldIndex)
                {
                    recompute_values(previewMemStore);
                });


                /*  GLOBALIZE GRID PROPERTIES  */
                window.previewGrid = grid;
                window.previewMemStore = previewMemStore;
                window.previewDataStore = previewDataStore;
                
            }

            /*  ON SELECTION CHANGE OF THE GROUP GRID, THE SELECTION GRID STORE IS REPOPULATED  */
            PreviewGrid.rebuildStore = function(pgs)
            {
                PreviewGrid.buildGrid(pgs);
            }


            /********************************     End Preview Grid      *********************************/

            /********************************     Family Grid      *********************************/


            /*  OBJECT TO ASSOCIATE ALL FUNCTIONS AND PROPERTIES OF THE FAMILY GRID  */
            var FamilyGrid = new Object();

            /*  QUERY THE GLOBAL DB STORE FOR FAMILY OBJECTS AND RETURN THE RESULT  */
            FamilyGrid.getFamilies = function()
            {
                var families = fullDbMemStore.query({type: 'pgf'});
                return families;
            }

            //DEFINE AND BUILD THE GRID GIVEN A SET OF FAMILY OBJECTS
            FamilyGrid.buildGrid = function(families)
            {
                //DEFINE THE LAYOUT
                var layout = [[
                  {'name': 'Family', 'field': 'name', 'width': '100%'},
                ]];

                //CREATE THE DATA STORE FOR THE FAMILY OBJECTS
                var FamilyMemStore = new Memory({data: new Array()}); //set up the store
                FamilyMemStore = Observable(FamilyMemStore);
                var FamilyDataStore = new ObjectStore({
                    objectStore: FamilyMemStore
                });

                //FILL THE STORE WITH THE FAMILY OBJECTS
                for(var i = 0; i < families.length; i++)
                {
                    FamilyMemStore.put(lang.mixin(
                        { id: i }, 
                        families[i]
                    ));
                }

                //IF THE GRID EXISTS IN THE REGISTRY, REMOVE IT
                registry.remove('FamilyGrid');

                //CREATE THE DOJO GRID AND RENDER IT
                var grid = new DataGrid({
                    store: FamilyDataStore,
                    structure: layout,
                    selectionMode: 'single'}, 'FamilyGrid');
                grid.startup(); //RENDER


                //ON MEMORY STORE EVENT 'NOTIFY', REFRESH THE GRID
                dojo.connect(FamilyMemStore, 'notify', function(){grid._refresh()});

                //IF THE DELETE KEY IS PRESSED, REMOVE THE SELECTED ELEMENT
                dojo.connect(grid,"onKeyUp", function(e)
                {
                    if(e.keyCode == 46 || e.keyCode == 8)
                    {
                        button_deletePGF.onClick();
                    }
                });


                //UPDATE THE SELECTION PROPERTY AND THE DIV ELEMENT                
                function reportSelection(node)
                {
                    //UPDATE SELECTED PROPERTY
                    var families = this.selection.getSelected();
                    FamilyGrid.selected_families = families;

                    //IF FAMILIES IS EMPTY OR NULL, BAIL
                    if(!families || families.length < 1)
                        return;

                    //GET THE PGs OF THE SELECTED PFs
                    var groups = families[0].members;

                    //REBUILD THE VIEWER STORE
                    FamilyViewerGrid.rebuildStore(groups);

                    //IF NOTHING IS SELECTED, BAIL
                    if(families.length < 1)
                        return;

                    //UPDATE THE DIV ELEMENT TO DISPLAY SELECTED
                    var msg = "You have selected " + ((FamilyGrid.selected_families.length > 1) ? " ": " ");
                    
                    //BUILD AN ARRAY OF THE NAMES OF SELECTED PFs
                    var names = [];
                    for(var i = 0; i <families.length;i++)
                        names.push(families[i].name);

                    //SET THE DIV ELEMENT VALUE TO THE NEW MESSAGE
                    node.innerHTML = msg + names.join(", ");
                }

                //REGISTER THE REPORT_SELECTION METHOD WITH THE SELECTION_CHANGED EVENT                
                grid.on("SelectionChanged", 
                    lang.hitch(grid, reportSelection, dom.byId("serverResponse")), true);

                //GLOBALIZE THE FAMILY GRID DATA PROPERTIES
                window.familyGrid = grid;
                window.FamilyMemStore = FamilyMemStore;
            }

            FamilyGrid.update_pgf = function(pgf)
            {
                var id = pgf.id;
                delete pgf.id;

                xhr.get(
                {
                    url:"/family", 
                    content: 
                    {
                        action: 'update_pgf',
                        pgf: JSON.stringify(pgf),
                        loaded: has_loaded=true,
                    },
                    load:function(response)
                    {
                        //if an update is successful, we'll receive a message, notify the user.
                        alert(response);
                        dom.byId("serverResponse").innerHTML = "Response from server: " + pgf.name + " successfully upated.";
                        dom.byId("txtBox_familyName").value = '';
                        FamilyMemStore.remove(id); //remove the old group from the store
                        // GroupGrid.add_to_group_store(pg); //add the change object to the store
                        try
                        {
                            FamilyMemStore.add(pgf);
                        }
                        catch(error)
                        {
                            console.log(pgf.name + 'already exists in this store');
                        }
                        // groupGrid._refresh(); //refresh the grid to display the update
                        familyGrid.selection.clear(); //clear the selection
                    },
                    error:function(error)
                    {
                        //log and alert the user of any error
                        console.log("There was an error: \n"+error);
                        alert("There was an error: \n"+error);
                        dom.byId("serverResponse").innerHTML = "Response from server: " + error;
                    }
                });
            }

            /*  BUILD THE PGF OBJECT TO SEND TO THE SERVER BY ANALYZING THE GROUPS AND EDITED VALUES  */
            FamilyGrid.analyzeNewPGF = function()
            {
                var pgf = {}; //OBJECT TO STORE THE PGF DATA
                pgf.type = 'pgf';
                pgf.name = dom.byId("txtBox_familyName").value;
                pgf.members = []; //PGF MEMBERS ARE GROUPS PGF MEMBERS CONTAIN MEMBERS (PARAMETERS)

                //GET GROUPS FROM GROUP STORE
                var groups = GroupMemStore.data;

                //MAKE EASY ACCESSOR FOR PREVIEW GRID DATA
                var store = previewGrid.store.objectStore.data; 

                var pgs = []; //build group members in this array

                //for each item in the preview grid add just the unique groups
                for(var i = 0; i < store.length; i++)
                {
                    var item = store[i];
                    if(pgs.indexOf(item.pg._id) == -1)
                        pgs.push(item.pg._id);
                }

                //for each unique group, store an object at its index with the groups id and an empty members array
                for(var i = 0; i < pgs.length; i++)
                {
                    var item = {};
                    item._id = pgs[i];
                    item.members = [];
                    pgs[i] = item;
                }

                //for each item in the preview grid
                for(var i = 0; i < store.length; i++)
                {
                    var matched = false; //flag when matched
                    var item = store[i];
                    //for each unique group in the grid
                    for(var j = 0; j < pgs.length; j++)
                    {
                        if(matched) //break if it's already been found
                            break;

                        var pg = pgs[j]; //current group

                        //if the current unique group id matches the current item's group id
                        if(pg._id == item.pg._id)
                        {
                            //add the current parameter to this unique group with its id and value
                            var p = {};
                            p._id = item.pi._id;
                            p.value = item.p_value;
                            pgs[j].members.push(p);
                            matched = true; //flag the match to discontinue the search
                        }
                    }
                }

                //store the new pgs as the pgf's members
                pgf.members = pgs;

                //submit the new pgf to the database
                FamilyGrid.newPGF(pgf);
            }

            /*  COMMITS A NEW PGF TO THE DB */
            FamilyGrid.newPGF = function(pgf)
            {
                //TELL THE SERVER TO ADD NEW PGF AND SEND THE NEW PGF OBJECT                
                xhr.get(
                {
                    url:"/family", 
                    handleAs: 'json',
                    content: 
                    {
                        action: 'new_pf',
                        pf: JSON.stringify(pgf),
                        loaded: has_loaded=true,
                    },
                    load:function(response)
                    {
                        //IF THE RETURNED OBJECT IS EMPTY, THEN IT ALREADY EXISTS, NOTIFY THE USER
                        if(objectIsEmpty(response))
                        {
                            dom.byId("serverResponse").innerHTML = "Response from server: " + pgf.name + " Already Exists.";
                            alert("'"+pgf.name+"' already exists in the database.");
                            return;
                        }
                        //UPDATE THE SERVER RESPONSE
                        dom.byId("serverResponse").innerHTML = "Response from server: "+pgf.name+" successfully added.";
                        dom.byId("txtBox_familyName").value = '';

                        //BECAUSE OF STRANGE ERRORS, TRYING TO ADD TO THE STORE IN PREVIOUS VERSIONS
                        //JUST GET THE ENTIRE DB AGAIN FROM THE SERVER.
                        init();
                    },
                    error:function(error)
                    {
                        //IF THERE WAS AN ERROR, REPORT IT IN THE CONSOLE AND TO THE USER
                        console.log("There was an error: \n"+error);
                        dom.byId("serverResponse").innerHTML = "Response from server: " + error;
                    }
                });
            }

            //FUNCTINO TO CLONE THE SELECTED PGF
            FamilyGrid.clonePGF = function(selected)
            {
                //IF NOTHING IS SELECTED, NOTIFY AND BAIL
                if(!selected)
                    return alert('Select a Family to Clone.');

                //IF THE DATA CAN'T BE RETRIEVED FROM THE SELECTED OBJECT, NOTIFY
                if(!selected[0]){ return alert('error cloning '+selected[0].name+'\''); }

                var copy = selected[0];

                //GENERATE A SUGGESTION FOR THE NEW NAME OF THE NEW PGF.
                var suggestion = get_suggested_clone_name(copy.name);

                //IF THE USER DOESN'T CONFIRM THAT THEY WANT TO DELETE THE SELECTED PF, BAIL
                var name = prompt("Give a name for the clone of \'" + copy.name +"\'.", suggestion);
                if(!name)
                    return;

                var pgf = {};

                pgf.name = name;
                pgf.type = copy.type;
                pgf.members = copy.members;


                FamilyGrid.newPGF(pgf);
            }

            //SUGGEST A NAME FOR THE CLONED FAMILY GIVEN THE FAMILY NAME TO CLONE
            get_suggested_clone_name = function(name)
            {
                var suggestion = '';
                //IF THE NAME CONTAINS NUMBERS
                if(/[vV]+\d/.test(name))
                {
                    var index = /[vV]+\d/.exec(name).index
                    var version_num = name.substring(index+1, name.length);
                    try
                    {
                        version_num++;
                    }
                    catch(error){return name + ' v2';}
                    if(!version_num)
                        return name + ' v2';
                    
                    suggestion = name.substring(0, index);
                    suggestion += 'v' + version_num; 
                    return suggestion;
                }
                return name + ' v2';
            }

            /*  REMOVES A PF FROM THE DATABASE GIVEN THE SELECTED PF  */
            FamilyGrid.removePGF = function(selected)
            {
                //IF NOTHING IS SELECTED, NOTIFY AND BAIL
                if(!selected)
                {
                    alert('Select a Family to Remove.');
                    return;
                }

                //IF THE DATA CAN'T BE RETRIEVED FROM THE SELECTED OBJECT, NOTIFY
                if(!selected[0]){ return alert('error deleting '+selected[0].name+'\''); }
                //IF THE USER DOESN'T CONFIRM THAT THEY WANT TO DELETE THE SELECTED PF, BAIL
                if(!confirm("Are you sure you want to delete \'" + selected[0].name +"\'?"))
                    return;

                //SEND THE SERVER A REQUEST TO REMOVE THE PF AND SEND THE PF OBJECT
                xhr.get(
                {
                    url:"/family",
                    content: 
                    {
                        action: 'remove_pf',
                        pf: JSON.stringify(selected[0]),
                        loaded: has_loaded=true,
                    },
                    load:function(response)
                    {
                        //TELL THE USER AND LOG THE RESPONSE
                        dom.byId("serverResponse").innerHTML = "Response from server: " + response;

                        //REMOVE THE ITEM FROM THE STORE
                        FamilyMemStore.remove(selected[0].id);
                        FamilyViewerGrid.buildGrid(new Array());
                        // remove_from_family_store();
                    },
                    error:function(error)
                    {
                        //NOTIFY THE USER AND LOG THE ERROR
                        console.log("There was an error: \n"+error);
                        alert("Failure to remove '"+selected[0].name+"' from the Database");
                        dom.byId("serverResponse").innerHTML = "Response from server: " + error;
                    }
                });
            }

            /********************************      End Family Grid      ********************************/


            /****************************   Begin Family Viewer Grid  *********************************/


            /*  AN OBJECT TO ASSOCIATE ALL FAMILY VIEWER FUNCTIONS AND PROPERTIES  */
            var FamilyViewerGrid = new Object();

            /*  DEFINE AND BUILD A GRID OF THE PROPERTIES OF A SELECTED FAMILY'S GIVEN PGs  */
            FamilyViewerGrid.buildGrid = function(pgs)
            {
                /*  DEFINE LAYOUT  */
                var layout = [[
                  {'name': 'Group', 'field': 'pg_name', 'width': '20%'},
                  {'name': 'Parameter', 'field': 'p_name', 'width': '33%'},
                  {'name': 'Formula', 'field': 'p_formula', 'width': '47%'},
                  {'name': 'Value', 'field': 'p_value', 'width': '47%', editable: true},
                ]];

                /*  SET UP STORE  */
                var FamilyViewerMemStore = new Memory({data: new Array(), idProperty: 'p_name'});
                FamilyViewerMemStore = Observable(FamilyViewerMemStore);
                var FamilyViewerDataStore = new ObjectStore({
                    objectStore: FamilyViewerMemStore
                });
                window.FamilyViewerMemStore = FamilyViewerMemStore;


                var holds = [];

                /*  POPULATE THE STORE  */
                for(var i = 0; i < pgs.length; i++)
                {
                    var pg = pgs[i];
                    var group = {};

                    for(var j = 0; j < GroupMemStore.data.length; j++)
                    {
                        var g = GroupMemStore.data[j];
                        if(pg._id == g._id)
                        {
                            group = g;
                            break;
                        }
                    }

                    var pis = group.members;
                    var pgf_pis = pg.members;


                    //DEFINE THE THE ROW FOR THE VIEWER GRID USING THE PI & PG DATA
                    for(var k = 0; k<pis.length; k++)
                    {
                        var matched = false;
                        var pi = pis[k];
                        if(!pi)
                            continue;

                        for(var l = 0; l < paramStore.data.length; l++)
                        {
                            if(matched)
                                break;
                            var p = paramStore.data[l];

                            if(pi == p._id)
                            {
                                row = {};
                                row.pg = group;
                                row.pg_name = group.name;
                                row.pi = p;
                                row.p_name = p.name;
                                row.p_formula = p.members.formula;
                                var matched_p = false;
                                for(var m = 0; m < pgf_pis.length; m++)
                                {
                                    if(matched_p)
                                        break;
                                    var pgf_p = pgf_pis[m];
                                    if(p._id == pgf_p._id && pgf_p.value)
                                    {
                                        matched_p = true;
                                        row.p_value = pgf_p.value;
                                        FamilyViewerMemStore.put(row);
                                        matched = true;
                                    }
                                    else if(m == pgf_pis.length - 1  && !matched_p)
                                    {
                                        row.p_value = p.members.formula;
                                        holds.push(row);
                                    }
                                }
                                // if(pi.value)
                                //     row.p_value = pi.value;
                                // else
                                //     row.p_value = p.members.formula;
                                
                            }
                        }
                    }
                }

                for(var i = 0; i < holds.length; i++)
                {
                    var hold_item = holds[i];
                    var matched_hold = false;
                    for(var m = 0; m < FamilyViewerMemStore.data.length; m++)
                    {
                        var store_item = FamilyViewerMemStore.data[m];
                        if(hold_item.pi._id == store_item.pi._id)
                        {
                            matched_hold = true;
                            continue;
                        }
                        else if(m == FamilyViewerMemStore.data.length - 1 && !matched_hold)
                        {
                            hold_item.p_name = hold_item.p_name + ' [#]';
                            FamilyViewerMemStore.put(hold_item);
                        }
                    }
                }

                //COMPUTE ALL THE VALUES
                recompute_values(FamilyViewerMemStore);

                // FamilyViewerGrid.rebuildStore(pgs);

                
                    //GET PIs OF CURRENT PG

                registry.remove('FamilyViewerGrid');

                /*  CREATE THE GRID AND RENDER IT  */
                var familyViewerGrid = new DataGrid({
                    store: FamilyViewerDataStore,
                    structure: layout,
                    selectionMode: 'single'}, "FamilyViewerGrid");
                familyViewerGrid.startup(); //RENDER

                dojo.connect(familyViewerGrid, "onApplyCellEdit", function(inValue, inRowIndex, inFieldIndex)
                {
                    recompute_values(FamilyViewerMemStore);
                });

                /*  GLOBALIZE GRID PROPERTIES  */
                window.familyViewerGrid = familyViewerGrid;
            }

            /*  ON SELECTION CHANGE OF THE FAMILY GRID, THE FAMILY VIEW GRID STORE IS REPOPULATED  */
            FamilyViewerGrid.rebuildStore = function(pgs)
            {
                // familyViewerGrid._refresh();
                FamilyViewerGrid.buildGrid(pgs);
            }

            FamilyViewerGrid.removeParameter = function(pgf)
            {
                var viewer_data = FamilyViewerMemStore.data;
                var selected = familyViewerGrid.selection.getSelected();
                var member_to_remove = selected[0];
                if(!member_to_remove)
                    return alert("Select a parameter to remove");
                var pg_ids = pgf.members;

                for(var i = 0; i < pg_ids.length; i++)
                {
                    var p_ids = pg_ids[i].members;
                    for(var j = 0; j < p_ids.length; j++)
                    {
                        if(p_ids[j]._id == member_to_remove.pi._id)
                        {
                            if(!confirm("Remove '" + member_to_remove.p_name + "'?"))
                                return;
                            p_ids.splice(j,1);
                        }
                    }
                }
                pgf.members.members = p_ids;
                delete pgf.id;
                FamilyViewerGrid.commitChanges(pgf);
            }

            /*  BUILD PGF OBJECT TO CHANGE BY ANALYZING THE CHANGES  */
            FamilyViewerGrid.analyzeChanges = function(pgf)
            {
                // pgf.type = 'pgf';
                // pgf.name = dom.byId("txtBox_familyName").value;
                // pgf.members = []; //PGF MEMBERS ARE GROUPS PGF MEMBERS CONTAIN MEMBERS (PARAMETERS)

                var groups = GroupMemStore.data;

                var store = FamilyViewerMemStore.data;

                var matched = false;
                var members = [];
                var pgs = [];
                var params = [];
                var group;
                for(var i = 0; i < store.length; i++)
                {
                    var item = store[i];
                    if(pgs.indexOf(item.pg._id) == -1)
                        pgs.push(item.pg._id);
                }
                for(var i = 0; i < pgs.length; i++)
                {
                    var item = {};
                    item._id = pgs[i];
                    item.members = [];
                    pgs[i] = item;
                }
                for(var i = 0; i < store.length; i++)
                {
                    var matched = false;
                    var item = store[i];
                    for(var j = 0; j < pgs.length; j++)
                    {
                        if(matched)
                            break;
                        var pg = pgs[j];
                        if(pg._id == item.pg._id)
                        {
                            var p = {};
                            p._id = item.pi._id;
                            p.value = item.p_value;
                            pgs[j].members.push(p);
                            matched = true;
                        }
                    }
                }
                pgf.members = pgs;

                delete pgf.id;

                FamilyViewerGrid.commitChanges(pgf);
            }

            FamilyViewerGrid.commitChanges = function(pgf)
            {
                //TELL THE SERVER TO ADD NEW PF AND SEND THE NEW PF OBJECT                
                xhr.get(
                {
                    url:"/family", 
                    handleAs: 'json',
                    content: 
                    {
                        action: 'change_pf',
                        pf: JSON.stringify(pgf),
                        loaded: has_loaded=true,
                    },
                    load:function(response)
                    {
                        //UPDATE THE SERVER RESPONSE
                        dom.byId("serverResponse").innerHTML = "Response from server: "+pgf.name+" successfully Changed.";
                        alert("Changes to '"+pgf.name+"' were succesful");
                        dom.byId("txtBox_familyName").value = '';

                        //THE SERVER WILL SEND BACK THE OBJECT IF THE ADD WAS SUCCESSFUL
                        //ADD THE OBJECT TO THE STORE
                        init();
                    },
                    error:function(error)
                    {
                        //IF THERE WAS AN ERROR, REPORT IT IN THE CONSOLE AND TO THE USER
                        alert("Failure: Changes to '"+pgf.name+"' were unsuccesful");
                        console.log("There was an error: \n"+error);
                        dom.byId("serverResponse").innerHTML = "Response from server: " + error;
                    }
                });
            }


            /****************************   TextBoxes / Button / Etc  *********************************/


            //Family Name Textbox
            var txtBox_familyName = new TextBox({},"txtBox_familyName");

            dojo.connect(txtBox_familyName, "onKeyUp", function(e)
            {
                if(e.keyCode == 13)
                    button_newPGF.onClick();
            });

            var button_add_to_existing_pgf = new Button(
            {
                label: "Add To Selected",
                onClick: function()
                {
                    var selected = familyGrid.selection.getSelected();
                    var pgf = selected[0];
                    if(!pgf)
                        return alert("Select a Family to add to.");
                    if(previewMemStore.data.length < 1)
                        return alert("There must be items in the Preview Grid to add to an existing family.");
                    var holds = [];
                    for(var i = 0; i < previewMemStore.data.length; i++)
                    {
                        var matched_p = false;
                        mem_to_add = previewMemStore.data[i];
                        for(var j = 0; j < pgf.members.length; j++)
                        {
                            if(matched_p)
                                break;
                            var group = pgf.members[j];
                            for(var k = 0; k < group.members.length; k++)
                            {
                                if(mem_to_add.pi._id == group.members[k])
                                {
                                    matched_p = true;
                                    break;
                                }
                            }
                        }

                        if(!matched_p && (j == pgf.members.length - 1))
                        {
                            var matched_pg = false;
                            for(var j = 0; j < pgf.members.length; j++)
                            {
                                if(matched_pg)
                                    break;
                                var pg = pgf.members[j];
                                if(mem_to_add.pg._id == pg)
                                {
                                    matched_pg = true;
                                    var pi = {};
                                    pi._id = mem_to_add.pi._id;
                                    pi.value = mem_to_add.p_value;
                                    pg.members.push(pi);
                                }
                                else if(!matched_pg && j == (pgf.members.length - 1))
                                {
                                    var new_pg = {};
                                    new_pg._id = mem_to_add.pg._id;
                                    new_pg.members = [];
                                    var pi = {};
                                    pi._id = mem_to_add.pi._id;
                                    pi.value = mem_to_add.p_value;
                                    new_pg.members.push(pi);
                                    pgf.members.push(new_pg);
                                }
                            }
                        }
                    }
                    return;
                    FamilyGrid.update_pgf(pgf);
                }
            }, "button_add_to_existing_pgf");

            //CREATE NEW PF BUTTON
            //REQUIRES A NAME
            var button_newPGF = new Button(
            {
                label: 'Commit',
                onClick: function()
                {
                    if(dom.byId('txtBox_familyName').value.length < 1)
                        return alert('A name is required for the new family.');
                    if(previewMemStore.data.length < 1)
                        return alert("There must be at least one item in the 'Preview' Grid.");
                    FamilyGrid.analyzeNewPGF();
                }
            }, "button_newPGF");

            //DELETE PF BUTTON
            var button_deletePGF = new Button(
                {
                    label: 'Delete', 
                    onClick: function()
                    {
                        FamilyGrid.removePGF(FamilyGrid.selected_families);
                    }
                }, "button_deletePGF");

            //DELETE PF BUTTON
            var button_clonePGF = new Button(
                {
                    label: 'Clone', 
                    onClick: function()
                    {
                        FamilyGrid.clonePGF(FamilyGrid.selected_families);
                    }
                }, "button_clonePGF");

            //DELETE PF BUTTON
            var button_deleteParameter = new Button(
                {
                    label: 'Delete', 
                    onClick: function()
                    {
                        FamilyViewerGrid.removeParameter(FamilyGrid.selected_families[0]);
                    }
                }, "button_deleteParameter");


            //COMMIT CHANGES PGF BUTTON
            var button_commitChanges = new Button(
                {
                    label: 'Commit Changes', 
                    onClick: function()
                    {
                        var selected = familyGrid.selection.getSelected();
                        var pgf = selected[0];
                        FamilyViewerGrid.analyzeChanges(pgf);
                    }
                }, "button_commitChanges");

            var button_add_member = new Button(
                {
                    label: '-->', 
                    onClick: function()
                    {
                        var pgs = groupGrid.selection.getSelected();
                        if(!pgs)
                            return;


                        /*  POPULATE THE STORE  */
                        for(var i = 0; i < pgs.length; i++)
                        {
                            var pg = pgs[i];
                            
                            //GET PIs OF CURRENT PG
                            var pis = pg.members;

                            //DEFINE THE THE ROW FOR THE PREVIEW GRID USING THE PI & PG DATA
                            for(var j = 0; j<pis.length; j++)
                            {
                                var row = {};
                                var pi = pis[j];
                                for(var k = 0; k < paramStore.data.length; k++)
                                {
                                    if(pi == paramStore.data[k]._id)
                                        pi = paramStore.data[k];
                                }
                                if(!pi.members)
                                    continue;
                                row.pg = pg;
                                row.pi = pi;
                                row.pg_name = pg.name;
                                row.p_name = pi.name;
                                row.p_formula = pi.members.formula;
                                row.p_value = pi.members.formula;
                                try
                                {
                                    previewMemStore.add(row);
                                }
                                catch(e){}
                            }
                        }

                        for(var i = 0; i < previewMemStore.data.length; i++)
                        {
                            var element1 = previewMemStore.data[i];
                            for(var j = 0; j < previewMemStore.data.length; j++)
                            {
                                var element2 = previewMemStore.data[j];
                                if ((element1.pi._id == element2.pi._id) && (element1.pg_name != element2.pg_name))
                                    previewMemStore.remove(element2.p_name);
                            }
                        }

                        var new_data = [];
                        for(var i = 0; i < previewMemStore.data.length; i++)
                        {
                            var element = previewMemStore.data[i];
                            var v_temp = realizeValue(previewMemStore.data, element.p_formula);
                            if(!v_temp == "")
                            {
                                element.p_value = v_temp;
                                new_data.push(element);
                            }
                        }
                        for(var i = 0;i < new_data.length; i++)
                        {
                            var element = new_data[i];
                            previewMemStore.remove(element.p_name);
                            try
                            {
                                previewMemStore.add(element); 
                            }
                            catch(e){console.log(element.p_name + ' is already in that set')};
                        }
                        // previewGrid._refresh();
                        groupGrid.selection.clear();
                    }
                }, "button_add_member");

            //BUTTON THAT WILL GET THE LATEST DATA FROM THE DATABASE AND REPOPULATE THE GRIDS
            var button_refresh_data = new Button(
            {
                label: 'Refresh All Data',
                onClick: function()
                {
                    init();
                }
            }, "button_refresh_data");

            //button to remove selected report members
            var button_remove_member = new Button(
                {
                    label: '<--', 
                    onClick: function()
                    { 
                        var mem_to_remove = previewGrid.selection.getSelected();
                        for(var i = 0;i < mem_to_remove.length; i++)
                        {
                            if(!mem_to_remove[i])
                                continue;
                            // var dependencies = mem_to_remove[i].members.dependencies;
                            // removeDependencies(dependencies);
                            previewMemStore.remove(mem_to_remove[i].p_name);
                        }
                        // previewGrid._refresh();
                    }
                }, "button_remove_member");

            var button_recompute = new Button(
            {
                label: "Recompute Values",
                onClick: function()
                {
                    recompute_values(previewMemStore);
                }
            }, "button_recompute");

            //Function that recomputes values for the given data store.
            var recompute_values = function(store)
            {
                var new_data = [];
                for(var i = 0; i < store.data.length; i++)
                {
                    var element = store.data[i];
                    var v_temp = realizeValue(store.data, element.p_formula);
                    if(!v_temp == "")
                    {
                        element.p_value = v_temp;
                        new_data.push(element);
                    }
                }
                for(var i = 0;i < new_data.length; i++)
                {
                    var element = new_data[i];
                    store.remove(element.p_name);
                    try
                    {
                        store.add(element); 
                    }
                    catch(e){console.log(element.p_name + " is already in this store");}
                }
            }


            /****************************   HELPER FUNCTIONS  *********************************/


            //PARSE THE GIVEN DEFINITION STRING
            //RETURNS AN EMPTY STRING IF THE FORMULA IS EMPTY
            function realizeValue(data, formula)
            {
                //SPLIT THE STRING BY ';' AND STORE THE ELEMENTS IN AN ARRAY
                if(formula.length < 1)
                    return "";
                var formula_elements = formula.split(";");

                //AN ARRAY TO MAKE UP THE PARSED ELEMENTS OF THE OUTPUT STRING
                var output_elements = [];

                //STRING FOR FINAL OUTPUT
                var output = '';

                //IF THERE ARE NO PIs OR THE ARRAY IS NULL,
                //REPORT AN ERROR
                if(data.length < 1 || data == null)
                {
                    output = 'There was a problem acquiring the parameters';
                    console.log('Parse Error: ' + output);
                    return output;
                } 
                //WHILE ELEMENTS REMAIN
                while(formula_elements.length > 0)
                {
                    //FLAG FOR WHEN AN ELEMENT IS MATCHED
                    var not_found = true;

                    //GET THE NEXT ELEMENT FROM THE ARRAY
                    var element = formula_elements.shift();

                    if(element == "")
                        continue;

                    //FIND THE ELEMENTS FROM THE GROUP AND MATCH THEM TO THE ELEMENTS
                    for(var i = 0; i < data.length; i++)
                    {
                        if(!not_found) //IF ELEMENT HAS BEEN MATCHED, BREAK 
                            break;

                        //STORE CURRENT PARAMETER
                        var e = data[i];

                        //IF THE ELEMENT AND THE PARAMETER NAME MATCH, GET THE PARAMETERS VALUE
                        if(element == e.p_name)
                        {
                            v_temp = realizeValue(data, e.p_formula); //circular dependencies
                            if(!v_temp == "")
                            {
                                e.p_value = v_temp;
                            }
                            if(/[\+\-\*\/]/.test(e.p_value))
                            {
                                try
                                {
                                    e.p_value = eval(e.p_value);
                                    e.p_value = e.p_value.toFixed(3); //ROUND TO 3 DECIMALS
                                }
                                catch(error)
                                {
                                    //if there's an error, ignore it and return the string as it was.
                                }
                            }
                            output_elements.push(e.p_value);
                            not_found = false;
                        }
                    }
                    //IF THE ELEMENT WAS NEVER MATCHED, IT'S PROBABLY A STRING OR AN OPERATOR, ADD IT TO THE OUTPUT
                    if(not_found)
                        output_elements.push(element);

                }
                //IF THERE ARE NO MORE ELEMENTS BUILD THE STRING AND RETURN IT
                if(formula_elements.length < 1)
                {
                    output = build_output_string(output_elements);
                    return output;
                }
                else //IF WE GET HERE AND HAVEN'T REPORTED THE STRING AND WE STILL HAVE ELEMENTS, THERE'S AN ERROR
                {
                    output = 'An unknown error occurred parsing the definition.';
                    return output;
                }
            }

            //BUILD THE OUTPUT STRING WITH THE GIVEN ARRAY OF STRINGS
            //RETURNS AN EMPTY STRING IF THE ELEMENTS ARE EMPTY
            function build_output_string(output_elements)
            {
                var output_string = '';
                if(output_elements.length < 1)
                    return "";
                for (var i = 0; i < output_elements.length; i++)
                {
                    output_string += output_elements[i];
                }

                output_elements = output_string.split("'");
                output_string = "";
                for(var i = 0; i < output_elements.length; i++)
                {
                    try
                    {
                        var e = output_elements[i];
                        if(!e)
                            break;
                        e = eval(e);
                        e = e.toFixed(1);
                        var index = e.indexOf('.0');
                        if(index > -1)
                        {
                            e = e.substring(0, index);
                        }
                        output_elements[i] = e;
                    }
                    catch(error){}
                }
                for (var i = 0; i < output_elements.length; i++)
                {
                    output_string += output_elements[i];
                }

                if(/[\+\-\*\/]/.test(output_string))
                {
                    try
                    {
                        output_string = eval(output_string);
                        output_string = output_string.toFixed(3); //ROUND TO 3 DECIMALS
                    }
                    catch(error)
                    {
                        //if there's an error, ignore it and return the string as it was.
                    }
                }

                return output_string;
            }     

            //HELPER FUNCTION TO CHECK IF AN OBJECT POSSESSES ANY PROPERTIES
            function objectIsEmpty(map) 
            {
               for(var key in map) 
               {
                  if (map.hasOwnProperty(key)) 
                  {
                     return false;
                  }
               }
               return true;
            }

            //ON LOAD, GET THE FULL DB AND PUT IT IN A GLOBAL STORE   
            init();
        });
    </script>
</head>

<!-- Layout -->
<body class="claro">
    <table width = '100%' border = "1">
        <col width = '47%'>
        <col width = '18%'>
        <col width = '35%'>
        <tr>
            <td style = "text-align: center; padding: 5px">
                <b>PGF Creator - Creates a New PGF</b>
                <div style = "text-align: right"><button id="button_add_to_existing_pgf"></button><button id = "button_newPGF"></button></div>
            </td>
            <td style = "text-align: center; vertical-align: top; padding: 5px">
                <b>PGF Lister - Lists All PGFs</b>
                <div style="text-align:right"><button id="button_clonePGF"></button>
                <button id="button_deletePGF"></button></div>
            </td>
            <td style = "text-align: center; vertical-align: top; padding: 5px">
                <b>PGF Viewer - Shows Selected PGF</b>
                <div style="text-align:right"><button id = "button_commitChanges"></button><button id="button_deleteParameter"></button></div>
            </td>
        </tr>
        <tr>
            <td valign = "top" style = "padding: 5px">
                <label for="txtBox_familyName">Name:</label><br>
                <input id="txtBox_familyName" data-dojo-type="dijit/form/TextBox" style="width: 50%;"></input>
                <table width = '100%'>
                    <col width = '22%'>
                    <col width = '6%'>
                    <col width = '72%'>
                    <tr>
                        <td>
                            <div style = "padding: 5px" align='center'><b>Groups</b><div>
                        </td>
                        <td colspan = '2'>
                            <table width="100%">
                                <col width="60%">
                                <col width="40%">
                                <tr>
                                    <td align="right">
                                        <div style = "padding: 5px"><b>Preview</b><div>
                                    </td>
                                    <td align="right">
                                        <div style="text-align: right"><button  id="button_recompute"></button></div>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div id="GroupGridDiv"></div>
                        </td>
                        <td>
                            <div style="text-align: center; padding-top: 50px; padding-bottom: 50px"><button id = "button_add_member"></button></div>
                            <div style="text-align: center; padding-top: 50px; padding-bottom: 50px"><button id = "button_remove_member"></button></div>
                        </td>
                        <td>
                            <div id= "PreviewGrid"></div>
                        </td>
                    </tr>
                </table>
            </td>
            <td valign = "top" style = "padding: 5px; text-align:right">
                <div id="FamilyGrid"></div>
            </td>
            <td valign = "top" style = "padding: 5px; text-align:right">
                <div id="FamilyViewerGrid"></div>
            </td>
        </tr>
        <tr>
            <table id='consoleTable' border = '1' width='100%'>
                <col width="70%">
                <col width="30%">
                <tr>
                    <td style = "padding: 10px">
                        <div id="serverResponse">Awaiting Action...</div>
                    </td>
                    <td>
                        <div id = "parseDisplay" style = "padding: 2px">[#]: Denotes that the parameter is only a reference. It will not show up in the report. If you want it to be added to the family, click the "Commit Changes" button.</div>
                    </td>
                </tr>
            </table id='consoleTable'>
        </tr>
    </table>
</body>
</html>