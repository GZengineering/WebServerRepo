<!DOCTYPE html>
<!-- This code was written by Alex Stout for Goal Zero, LLC private use -->
<html lang='en' style= 'background-color:#666666; padding: 0px 25px 25px'>
<head>
    <title>Parameter: Family</title>
    <h1 ALIGN = 'center' style = 'padding: 10px'> Parameter: Family </h1>

    <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dojo/resources/dojo.css">
    <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dijit/themes/claro/claro.css">
    <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dojox/grid/resources/claroGrid.css">
        
    <style type="text/css">@import "http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dojox/grid/resources/claroGrid.css";
        #FamilyGrid
        {
            height: 51em;
            width: 100%;
        }
        #selectionGrid 
        {
            height: 42em;
            width: 100%;
        }
        #GroupGridDiv 
        {
            height: 42em;
            width: 100%;
        }
        #FamilyViewerGrid
        {
            height: 51em;
            width: 100%;
        }
        .dojoxGridMasterView
        {
            font-size: 8pt;
        }
        .dojoxGridMasterHeader
        {
            font-size: 8pt;
        }
    </style>
    <script src="http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dojo/dojo.js" data-dojo-config="async: true, isDebug: true">
    </script>

    <!-- Dojo Execution -->
    <script>
    require(['dojo/_base/lang', 
        'dojox/grid/DataGrid' , 
        'dojo/data/ItemFileWriteStore' ,
        "dojo/_base/array",
        'dijit/registry',
        'dojo/_base/xhr', 
        'dijit/form/RadioButton',
        'dojox/grid/_CheckBoxSelector',
        "dijit/form/Button",
        'dijit/form/TextBox', 
        'dojo/store/Observable',
        'dojo/store/Memory',
        'dojo/data/ObjectStore',
        'dojo/dom' , 
        'dojo/domReady!'],
      function(lang, DataGrid, ItemFileWriteStore, baseArray, registry, xhr, RadioButton, _CheckBoxSelector, Button, TextBox, Observable, Memory, ObjectStore, dom)
        {
            /*  THIS FLAG NOTIFIES THE SERVER WHETHER THE HTML FOR THIS PAGE HAS ALREADY BEEN LOADED  */
            var has_loaded = false;

            /*  CREATE A DATA STORE TO CONTAIN ALL THE CONTENT OF THE SERVER  */
            var fullDbMemStore = new Memory({data: new Array()});
                fullDbMemStore = Observable(fullDbMemStore);
                var fullDataStore = new ObjectStore({
                    objectStore: fullDbMemStore
                });
            window.fullDbMemStore = fullDbMemStore; //MAKE IT GLOBAL

            /*  FUNCTION TO GET ALL THE DB DATA AND FILL THE DATA STORE  */
            GetFullDbStore = function()
            {
                xhr.get(
                {
                    url:'/global',
                    handleAs: 'json',
                    content:
                    {
                        action: 'getAll',
                        loaded: has_loaded = true,
                    },
                    load: function(response)
                    {
                        fullDbMemStore.data = response;
                        BuildGrids();
                    },
                    error: function(error)
                    {
                        var msg = 'There was an error getting the db. Error: ' + error;
                        dom.byId("serverResponse").innerHTML = 'Response: ' + msg;
                        console.log(msg);
                    }
                });
            }


            /*  BUILDS THE GRIDS USING THE COLLECTED AND ORGANIZED DATA  */
            function BuildGrids()
            {
                //QUERY TO GET THE PARAMETERS FROM THE FULL STORE
                var parameters = fullDbMemStore.query({type: "param_class"});
                var paramStore = new Memory({data: parameters});
                    paramStore = Observable(paramStore);
                    var paramDataStore = new ObjectStore({
                        objectStore: paramStore
                    });

                //GLOBALIZE THE PARAMETER STORE
                window.paramStore = paramStore;
                window.paramDataStore = paramDataStore;
                
                //GET GROUPS AND BUILD THE GROUP GRID
                var groups = GroupGrid.getGroups();
                GroupGrid.buildGrid(groups);

                //GET FAMILIES AND BUILD THE FAMILY GRID
                var families = FamilyGrid.getFamilies();
                FamilyGrid.buildGrid(families);

                //BUILD EMPTY SELECTION/FAMILY VIEWER GRIDS
                SelectionGrid.buildGrid(new Array());
                FamilyViewerGrid.buildGrid(new Array());

                //clear name text field
                dom.byId('txtBox_familyName').value = '';
            }


            /********************************     Group Grid      *********************************/

            var GroupGrid = new Object();

            //GET AND RETURN THE GROUPS FROM THE STORE
            GroupGrid.getGroups = function()
            {
                var groups = fullDbMemStore.query({type: 'param_group'});
                return groups;
            }

            //BUILD THE DOJO GRID WITH THE GIVEN ARRAY OF GROUPS
            GroupGrid.buildGrid = function(groups)
            {
                //DEFINE THE LAYOUT
                var layout = [{type: 'dojox.grid._CheckBoxSelector'},[
                  {'name': 'Group', 'field': 'name', 'width': '100%'},
                ]];

                //ALLOCATE THE STORE
                var GroupMemStore = new Memory({data: new Array()}); //set up the store
                GroupMemStore = Observable(GroupMemStore);
                var GroupDataStore = new ObjectStore({
                    objectStore: GroupMemStore
                });
                
                //Fill the store with the retrieved DB data
                for(var i = 0; i < groups.length; i++)
                {
                    GroupMemStore.put(lang.mixin(
                        { id: i }, 
                        groups[i]
                    ));
                }

                //REMOVE FROM THE REGISTRY IF IT EXISTS
                registry.remove('GroupGridDiv');

                /*create a new grid*/
                var grid = new DataGrid({
                    store: GroupDataStore,
                    structure: layout}, 'GroupGridDiv');
                grid.startup(); //RENDER

                //REGISTER THE NOTIFY EVENT TO REFRESH THE GRID
                dojo.connect(GroupMemStore, 'notify', function(){grid._refresh()});
                

                //UPDATE THE GROUP SELECTION AND DISPLAY IT IN THE RESPONSE DIV
                function reportSelection(node)
                {
                    //STORE THE SELECTED ITEMS
                    var groups = this.selection.getSelected();
                    GroupGrid.selected_groups = groups;
                    console.log(groups);

                    //GET THE PIs OF THE SELECTED GROUP & REBUILD THE SELECTION STORE
                    var parameters = GroupGrid.getFieldsOfGroups(groups);
                    console.log(parameters);
                    SelectionGrid.rebuildStore(groups);

                    /*  DISPLAY WHAT'S SELECTED IN THE PROMPT  */
                    if(groups.length < 1)
                        return;

                    var msg = "You have selected " + ((groups.length > 1) ? " ": " ");
                    //FOR EACH PG IN GROUPS, GET THE PG_NAME AND PUT IT IN AN ARRAY 
                    var names = [];
                    for(var i = 0; i < groups.length; i++)
                    {
                        if(!groups[i])
                            return;
                        names.push(groups[i].name);
                    }

                    //UPDATE RESPONSE DIV
                    node.innerHTML = msg + names.join(", ");
                }
                
                //On selection change, call reportSelection() and pass in the response dom
                grid.on("SelectionChanged", 
                    lang.hitch(grid, reportSelection, dom.byId("serverResponse")), true);


                //GLOBALIZE GRID AND STORE
                window.groupGrid = grid;
                window.GroupMemStore = GroupMemStore;
            }


            //GETS AND RETURNS ALL THE PIs OF THE GIVEN PGs
            GroupGrid.getFieldsOfGroups = function(pgs)
            {
                //IF THE GIVEN ARRAY IS EMPTY, RETURN AN EMPTY ARRAY
                if(pgs.length < 1)
                {
                    return new Array();
                }

                //CREATE AN ARRAY TO STORE REALIZED PIs
                var parameters = [];

                //FOR EACH GROUP IN THE GIVEN PGs, MATCH THE PI IDs TO IDs IN THE STORE
                //IF A MATCH IS FOUND, ADD IT TO THE STORE AND MOVE TO THE NEXT PI
                for(var h = 0; h < pgs.length; h++)
                {   
                    //STORE THE CURRENT PG
                    var pg = pgs[h];

                    //IF THE PG IS NULL, BAIL
                    if(!pg)
                        return;

                    for(var i = 0; i < pg.members.length; i++)
                    {
                        var pg_member_id = {}; //OBJECT FOR CURRENT MEMBER ID

                        //IF WE ARE DEALING WITH A FULL PARAMETER OBJECT, GET THE ID OF THE OBJECT
                        //OTHERWISE WE SHOULD BE REFERENCING THE ID OF THE PARAMETER
                        if(pg.members[i]._id)
                            pg_member_id = pg.members[i]._id;
                        else
                            pg_member_id = pg.members[i];                            
                        //FLAGS IF A MATCH IS FOUND
                        var matched = false;
                        for(var j = 0; j < paramStore.data.length; j++)
                        {
                            if(matched)
                                break;
                            //TRY TO MATCH THE CURRENT PI ID TO AN ID IN THE STORE
                            if(pg_member_id == paramStore.data[j]._id)
                            {
                                //IF THERE'S A MATCH, PUSH THE PI OBJECT TO THE ARRAY
                                if(parameters.indexOf(paramStore.data[j]) == -1)
                                {
                                    parameters.push(paramStore.data[j]);
                                    matched = true;
                                }
                            }
                        }
                    }
                }
                console.log(parameters);

                //RETURN THE RESULTING ARRAY
                return parameters;
            }

            /********************************      End Group Grid      ********************************/


            /*******************************    BEGIN SELECTION GRID    ******************************/

            //OBJECT TO ASSOCIATE ALL FUNCTIONS AND PROPERTIES OF THE SELECTION GRID
            var SelectionGrid = new Object();
            
            /*  BUILD THE GRID GIVEN THE PIs AS A PARAMETER  */
            SelectionGrid.buildGrid = function(pgs)
            {
                /*  DEFINE LAYOUT  */
                var layout = [[
                  {'name': 'Group', 'field': 'pg_name', 'width': '15%'},
                  {'name': 'Parameter', 'field': 'p_name', 'width': '15%'},
                  {'name': 'Formula', 'field': 'p_formula', 'width': '40%', editable: true},
                  {'name': 'Value', 'field': 'p_value', 'width': '30%', editable: true},
                ]];


                /*  SET UP DATA STORE  */
                var selectionMemStore = new Memory({data: new Array()});
                selectionMemStore = Observable(selectionMemStore);
                var selectionDataStore = new ObjectStore({
                    objectStore: selectionMemStore
                });

                /*  POPULATE THE STORE  */
                for(var i = 0; i < pgs.length; i++)
                {
                    var pg = pgs[i];
                    
                    //GET PIs OF CURRENT PG
                    var pis = pg.members;

                    //DEFINE THE THE ROW FOR THE VIEWER GRID USING THE PI & PG DATA
                    for(var j = 0; j<pis.length; j++)
                    {
                        var row = {};
                        var pi = pis[j];
                        for(var k = 0; k < paramStore.data.length; k++)
                        {
                            if(pi == paramStore.data[k]._id)
                                pi = paramStore.data[k];
                        }
                        row.pg = pg;
                        row.pi = pi;
                        row.pg_name = pg.name;
                        row.p_name = pi.name;
                        row.p_formula = pi.members.formula;
                        row.p_value = pi.members.formula;
                        selectionMemStore.put(row);
                    }
                }

                var new_data = [];
                for(var i = 0; i < selectionMemStore.data.length; i++)
                {
                    var element = selectionMemStore.data[i];
                    console.log(element);
                    var v_temp = realizeValue(selectionMemStore.data, element.p_formula);
                    if(!v_temp == "")
                    {
                        element.p_value = v_temp;
                        new_data.push(element);
                    }
                }
                for(var i = 0;i < new_data.length; i++)
                {
                    var element = new_data[i];
                    selectionMemStore.remove(element.id);
                    selectionMemStore.add(element); 
                }


                //REMOVE FROM REGISTRY IF IT EXISTS
                registry.remove('selectionGrid');


                /*  CREATE THE DOJO GRID AND RENDER IT  */
                var selectionGrid = new DataGrid({
                    store: selectionDataStore,
                    structure: layout}, "selectionGrid");
                selectionGrid.startup();


                dojo.connect(selectionGrid, "onApplyCellEdit", function(inValue, inRowIndex, inFieldIndex)
                {
                    button_recompute.onClick();
                });


                /*  GLOBALIZE GRID PROPERTIES  */
                window.selectionGrid = selectionGrid;
                window.selectionMemStore = selectionMemStore;
                window.selectionDataStore = selectionDataStore;
            }

            /*  ON SELECTION CHANGE OF THE GROUP GRID, THE SELECTION GRID STORE IS REPOPULATED  */
            SelectionGrid.rebuildStore = function(pgs)
            {
                SelectionGrid.buildGrid(pgs);
            }


            /********************************     End Selection Grid      *********************************/

            /********************************     Family Grid      *********************************/


            /*  OBJECT TO ASSOCIATE ALL FUNCTIONS AND PROPERTIES OF THE FAMILY GRID  */
            var FamilyGrid = new Object();

            /*  QUERY THE GLOBAL DB STORE FOR FAMILY OBJECTS AND RETURN THE RESULT  */
            FamilyGrid.getFamilies = function()
            {
                var families = fullDbMemStore.query({type: 'pgf'});
                return families;
            }

            //DEFINE AND BUILD THE GRID GIVEN A SET OF FAMILY OBJECTS
            FamilyGrid.buildGrid = function(families)
            {
                //DEFINE THE LAYOUT
                var layout = [[
                  {'name': 'Family', 'field': 'name', 'width': '100%'},
                ]];

                //CREATE THE DATA STORE FOR THE FAMILY OBJECTS
                var FamilyMemStore = new Memory({data: new Array()}); //set up the store
                FamilyMemStore = Observable(FamilyMemStore);
                var FamilyDataStore = new ObjectStore({
                    objectStore: FamilyMemStore
                });

                //FILL THE STORE WITH THE FAMILY OBJECTS
                for(var i = 0; i < families.length; i++)
                {
                    FamilyMemStore.put(lang.mixin(
                        { id: i }, 
                        families[i]
                    ));
                }

                //IF THE GRID EXISTS IN THE REGISTRY, REMOVE IT
                registry.remove('FamilyGrid');

                //CREATE THE DOJO GRID AND RENDER IT
                var grid = new DataGrid({
                    store: FamilyDataStore,
                    structure: layout,
                    selectionMode: 'single'}, 'FamilyGrid');
                grid.startup(); //RENDER


                //ON MEMORY STORE EVENT 'NOTIFY', REFRESH THE GRID
                dojo.connect(FamilyMemStore, 'notify', function(){grid._refresh()});

                //IF THE DELETE KEY IS PRESSED, REMOVE THE SELECTED ELEMENT
                dojo.connect(grid,"onKeyUp", function(e)
                {
                    if(e.keyCode == 46 || e.keyCode == 8)
                    {
                        button_deletePGF.onClick();
                    }
                });


                //UPDATE THE SELECTION PROPERTY AND THE DIV ELEMENT                
                function reportSelection(node)
                {
                    //UPDATE SELECTED PROPERTY
                    var families = this.selection.getSelected();
                    FamilyGrid.selected_families = families;

                    //IF FAMILIES IS EMPTY OR NULL, BAIL
                    if(!families || families.length < 1)
                        return;

                    //GET THE PGs OF THE SELECTED PFs
                    var groups = families[0].members;

                    //REBUILD THE VIEWER STORE
                    FamilyViewerGrid.rebuildStore(groups);

                    //IF NOTHING IS SELECTED, BAIL
                    if(families.length < 1)
                        return;

                    //UPDATE THE DIV ELEMENT TO DISPLAY SELECTED
                    var msg = "You have selected " + ((FamilyGrid.selected_families.length > 1) ? " ": " ");
                    
                    //BUILD AN ARRAY OF THE NAMES OF SELECTED PFs
                    var names = [];
                    for(var i = 0; i <families.length;i++)
                        names.push(families[i].name);

                    //SET THE DIV ELEMENT VALUE TO THE NEW MESSAGE
                    node.innerHTML = msg + names.join(", ");
                }

                //REGISTER THE REPORT_SELECTION METHOD WITH THE SELECTION_CHANGED EVENT                
                grid.on("SelectionChanged", 
                    lang.hitch(grid, reportSelection, dom.byId("serverResponse")), true);

                //GLOBALIZE THE FAMILY GRID DATA PROPERTIES
                window.familyGrid = grid;
                window.FamilyMemStore = FamilyMemStore;
            }

            /*  BUILD THE PGF OBJECT TO SEND TO THE SERVER BY ANALYZING THE GROUPS AND EDITED VALUES  */
            FamilyGrid.analyzeNewPGF = function(groups)
            {
                var pgf = {}; //OBJECT TO STORE THE PGF DATA
                pgf.type = 'pgf';
                pgf.name = dom.byId("txtBox_familyName").value;
                pgf.members = []; //PGF MEMBERS ARE GROUPS PGF MEMBERS CONTAIN MEMBERS (PARAMETERS)


                for(var i = 0; i < groups.length; i++)
                {
                    var group = groups[i]; //STORE CURRENT GROUP
                    //GET THE PARAMETERS OF THE CURRENT GROUP
                    var members = []; //ARRAY TO STORE COLLECTED MEMBERS FOR THE GROUP

                    //FOR EACH MEMBER OF THE CURRENT GROUP
                    for(var j = 0; j < group.members.length; j++)
                    {
                        var match = false; //FLAGS WHEN A MATCH IS FOUND
                        var member_id = group.members[j]; //STORE CURRENT MEMBER ID
                        var store = selectionGrid.store.objectStore.data; 

                        //CHECK EACH ITEM IN THE STORE AGAINST THE CURRENT GROUPS MEMBERS
                        for (var k = 0; k < store.length; k++)
                        {
                            if(match) //IF A MATCH IS FOUND, BREAK THE LOOP
                                break;
                            var item = store[k]; //STORE THE CURRENT ITEM
                            if(member_id == item.pi._id && item.pg_name == group.name)
                            {
                                var temp = {};
                                temp._id = item.pi._id;
                                temp.value = item.p_value;
                                members.push(temp); //PUSH THE ITEM TO THE MEMBERS ARRAY
                                match = true; //FLAG THE MATCH
                            }
                        }
                    }
                    group.members = members; //SET THE GROUP MEMBERS TO THE OBTAINED MEMBERS ARRAY

                    var g = {};
                    g._id = group._id;
                    g.members = members;

                    members.standard = members.standard; //SET THE GROUP MEMBERS TO THE OBTAINED MEMBERS ARRAY
                    pgf.members.push(g); //PUT EACH GROUP INTO THE MEMBERS OF THIS PGF
                }

                FamilyGrid.newPGF(pgf); //COMMIT THE NEW PGF
            }

            /*  CREATES A NEW PGF  */
            FamilyGrid.newPGF = function(pgf)
            {
                //TELL THE SERVER TO ADD NEW PGF AND SEND THE NEW PGF OBJECT                
                xhr.get(
                {
                    url:"/family", 
                    handleAs: 'json',
                    content: 
                    {
                        action: 'new_pf',
                        pf: JSON.stringify(pgf),
                        loaded: has_loaded=true,
                    },
                    load:function(response)
                    {
                        if(objectIsEmpty(response))
                        {
                            dom.byId("serverResponse").innerHTML = "Response from server: " + pgf.name + " Already Exists.";
                            alert("'"+pgf.name+"' already exists in the database.");
                            return;
                        }
                        //UPDATE THE SERVER RESPONSE
                        dom.byId("serverResponse").innerHTML = "Response from server: "+pgf.name+" successfully added.";
                        dom.byId("txtBox_familyName").value = '';
                        console.log(response);

                        //BECAUSE OF STRANGE ERRORS, TRYING TO ADD TO THE STORE IN PREVIOUS VERSIONS
                        //JUST GET THE ENTIRE DB AGAIN FROM THE SERVER.
                        GetFullDbStore();
                    },
                    error:function(error)
                    {
                        //IF THERE WAS AN ERROR, REPORT IT IN THE CONSOLE AND TO THE USER
                        console.log("There was an error: \n"+error);
                        dom.byId("serverResponse").innerHTML = "Response from server: " + error;
                    }
                });
            }

            FamilyGrid.clonePGF = function(selected)
            {
                //IF NOTHING IS SELECTED, NOTIFY AND BAIL
                if(!selected)
                {
                    return alert('Select a Family to Clone.');
                }

                //IF THE DATA CAN'T BE RETRIEVED FROM THE SELECTED OBJECT, NOTIFY
                if(!selected[0]){ return alert('error cloning '+selected[0].name+'\''); }

                var copy = selected[0];

                var suggestion = get_suggested_clone_name(copy.name);

                //IF THE USER DOESN'T CONFIRM THAT THEY WANT TO DELETE THE SELECTED PF, BAIL
                var name = prompt("Give a name for the clone of \'" + copy.name +"\'.", suggestion);
                if(!name)
                {
                    return;
                }

                var pgf = {};

                pgf.name = name;
                pgf.type = copy.type;
                pgf.members = copy.members;

                console.log(pgf);

                FamilyGrid.newPGF(pgf);
            }

            //SUGGEST A NAME FOR THE CLONED FAMILY GIVEN THE FAMILY NAME TO CLONE
            get_suggested_clone_name = function(name)
            {
                var suggestion = '';
                //IF THE NAME CONTAINS NUMBERS
                if(/[vV]+\d/.test(name))
                {
                    var index = /[vV]+\d/.exec(name).index
                    var version_num = name.substring(index+1, name.length);
                    try
                    {
                        version_num++;
                    }
                    catch(error){return name + ' v2';}
                    if(!version_num)
                        return name + ' v2';
                    
                    suggestion = name.substring(0, index);
                    suggestion += 'v' + version_num; 
                    return suggestion;
                }
                return name + ' v2';
            }


            /*  REMOVES A PF FROM THE DATABASE GIVEN THE SELECTED PF  */
            FamilyGrid.removePGF = function(selected)
            {
                //IF NOTHING IS SELECTED, NOTIFY AND BAIL
                if(!selected)
                {
                    alert('Select a Family to Remove.');
                    return;
                }

                //IF THE DATA CAN'T BE RETRIEVED FROM THE SELECTED OBJECT, NOTIFY
                if(!selected[0]){ return alert('error deleting '+selected[0].name+'\''); }
                //IF THE USER DOESN'T CONFIRM THAT THEY WANT TO DELETE THE SELECTED PF, BAIL
                if(!confirm("Are you sure you want to delete \'" + selected[0].name +"\'?"))
                    return;

                //SEND THE SERVER A REQUEST TO REMOVE THE PF AND SEND THE PF OBJECT
                xhr.get(
                {
                    url:"/family",
                    content: 
                    {
                        action: 'remove_pf',
                        pf: JSON.stringify(selected[0]),
                        loaded: has_loaded=true,
                    },
                    load:function(response)
                    {
                        //TELL THE USER AND LOG THE RESPONSE
                        dom.byId("serverResponse").innerHTML = "Response from server: " + response;

                        //REMOVE THE ITEM FROM THE STORE
                        remove_from_family_store();
                    },
                    error:function(error)
                    {
                        //NOTIFY THE USER AND LOG THE ERROR
                        console.log("There was an error: \n"+error);
                        alert("Failure to remove '"+selected[0].name+"' from the Database");
                        dom.byId("serverResponse").innerHTML = "Response from server: " + error;
                    }
                });

                /*  REMOVES THE FIRST ELEMENT OF THE SELECTED PFs  */
                remove_from_family_store = function()
                {
                    FamilyMemStore.remove(selected[0].id);
                }
            }

            /********************************      End Family Grid      ********************************/


            /****************************   Begin Family Viewer Grid  *********************************/


            /*  AN OBJECT TO ASSOCIATE ALL FAMILY VIEWER FUNCTIONS AND PROPERTIES  */
            var FamilyViewerGrid = new Object();

            /*  DEFINE AND BUILD A GRID OF THE PROPERTIES OF A SELECTED FAMILY'S GIVEN PGs  */
            FamilyViewerGrid.buildGrid = function(pgs)
            {
                /*  DEFINE LAYOUT  */
                var layout = [[
                  {'name': 'Group', 'field': 'pg_name', 'width': '20%'},
                  {'name': 'Parameter', 'field': 'p_name', 'width': '33%'},
                  {'name': 'Formula', 'field': 'p_formula', 'width': '47%'},
                  {'name': 'Value', 'field': 'p_value', 'width': '47%', editable: true},
                ]];

                /*  SET UP STORE  */
                var FamilyViewerMemStore = new Memory({data: new Array()});
                FamilyViewerMemStore = Observable(FamilyViewerMemStore);
                var FamilyViewerDataStore = new ObjectStore({
                    objectStore: FamilyViewerMemStore
                });

                /*  POPULATE THE STORE  */

                for(var i = 0; i < pgs.length; i++)
                {
                    var pg = pgs[i];
                    var group = {};

                    for(var j = 0; j < GroupMemStore.data.length; j++)
                    {
                        var g = GroupMemStore.data[j];
                        if(pg._id == g._id)
                        {
                            group = g;
                            break;
                        }
                    }


                    var pis = pg.members;

                    //DEFINE THE THE ROW FOR THE VIEWER GRID USING THE PI & PG DATA
                    for(var k = 0; k<pis.length; k++)
                    {
                        var matched = false;
                        var pi = pis[k];

                        for(var l = 0; l < paramStore.data.length; l++)
                        {
                            if(matched)
                                break;
                            var p = paramStore.data[l];

                            if(pi._id == p._id)
                            {
                                row = {};
                                row.pg = group;
                                row.pg_name = group.name;
                                row.pi = p;
                                row.p_name = p.name;
                                row.p_formula = p.members.formula;
                                row.p_value = pi.value;
                                FamilyViewerMemStore.put(row);
                                matched = true;
                            }
                        }
                    }
                }

                //COMPUTE ALL THE VALUES
                recompute_values(FamilyViewerMemStore);
                    //GET PIs OF CURRENT PG

                registry.remove('FamilyViewerGrid');

                /*  CREATE THE GRID AND RENDER IT  */
                var familyViewerGrid = new DataGrid({
                    store: FamilyViewerDataStore,
                    structure: layout,
                    selectionMode: 'single'}, "FamilyViewerGrid");
                familyViewerGrid.startup(); //RENDER

                dojo.connect(familyViewerGrid, "onApplyCellEdit", function(inValue, inRowIndex, inFieldIndex)
                {
                    recompute_values(FamilyViewerMemStore);
                });

                /*  GLOBALIZE GRID PROPERTIES  */
                window.familyViewerGrid = familyViewerGrid;
                window.FamilyViewerMemStore = FamilyViewerMemStore;
            }

            /*  ON SELECTION CHANGE OF THE FAMILY GRID, THE FAMILY VIEW GRID STORE IS REPOPULATED  */
            FamilyViewerGrid.rebuildStore = function(pgs)
            {
                FamilyViewerGrid.buildGrid(pgs);
            }

            FamilyViewerGrid.removeParameter = function(pgf)
            {
                console.log(pgf);
                var viewer_data = FamilyViewerMemStore.data;
                var selected = familyViewerGrid.selection.getSelected();
                var member_to_remove = selected[0];
                if(!member_to_remove)
                    return alert("Select a parameter to remove");
                var pg_ids = pgf.members;

                for(var i = 0; i < pg_ids.length; i++)
                {
                    var p_ids = pg_ids[i].members;
                    for(var j = 0; j < p_ids.length; j++)
                    {
                        if(p_ids[j]._id == member_to_remove.pi._id)
                        {
                            if(!confirm("Remove '" + member_to_remove.p_name + "'?"))
                                return;
                            p_ids.splice(j,1);
                        }
                    }
                }
                pgf.members.members = p_ids;
                console.log(pgf);
                delete pgf.id;
                FamilyViewerGrid.commitChanges(pgf);
            }

            /*  BUILD PGF OBJECT TO CHANGE BY ANALYZING THE CHANGES  */
            FamilyViewerGrid.analyzeChanges = function(pgf)
            {
                console.log(pgf);
                var viewer_data = FamilyViewerMemStore.data;
                var pg_ids = pgf.members;

                //FOR EACH PARAMETER OF EACH GROUP OF THE PGF, GET THE VALUE FROM THE PARAMETER IN THE GRID AND STORE IT IN
                //THIS PGF'S PARAMETER
                for(var i = 0; i < pg_ids.length; i++)
                {
                    var p_ids = pg_ids[i].members;
                    for(var j = 0; j < p_ids.length; j++)
                    {
                        for(var k = 0; k < viewer_data.length; k++)
                        {
                            if(viewer_data[k].pi._id == p_ids[j]._id)
                            {
                                p_ids[j].value = viewer_data[k].p_value;
                            }
                        }
                    }
                    pgf.members[i].members = p_ids; //SET THE PARAMETERS OF 
                }   
                delete pgf.id;

                FamilyViewerGrid.commitChanges(pgf);
            }

            FamilyViewerGrid.commitChanges = function(pgf)
            {
                //TELL THE SERVER TO ADD NEW PF AND SEND THE NEW PF OBJECT                
                xhr.get(
                {
                    url:"/family", 
                    handleAs: 'json',
                    content: 
                    {
                        action: 'change_pf',
                        pf: JSON.stringify(pgf),
                        loaded: has_loaded=true,
                    },
                    load:function(response)
                    {
                        //UPDATE THE SERVER RESPONSE
                        dom.byId("serverResponse").innerHTML = "Response from server: "+pgf.name+" successfully Changed.";
                        alert("Changes to '"+pgf.name+"' were succesful");
                        dom.byId("txtBox_familyName").value = '';
                        console.log(response);

                        //THE SERVER WILL SEND BACK THE OBJECT IF THE ADD WAS SUCCESSFUL
                        //ADD THE OBJECT TO THE STORE
                        GetFullDbStore();
                    },
                    error:function(error)
                    {
                        //IF THERE WAS AN ERROR, REPORT IT IN THE CONSOLE AND TO THE USER
                        alert("Failure: Changes to '"+pgf.name+"' were unsuccesful");
                        console.log("There was an error: \n"+error);
                        dom.byId("serverResponse").innerHTML = "Response from server: " + error;
                    }
                });
            }


            /****************************   TextBoxes / Button / Etc  *********************************/


            //Family Name Textbox
            var txtBox_familyName = new TextBox({},"txtBox_familyName");

            dojo.connect(txtBox_familyName, "onKeyUp", function(e)
            {
                if(e.keyCode == 13)
                    button_newPGF.onClick();
            });

            var button_add_to_existing_pgf = new Button(
            {
                label: "Add To Selected",
                onClick: function()
                {
                    var selected = familyGrid.selection.getSelected();
                    var pgf = selected[0];
                    if(!pgf)
                        return alert("Select a Family to add to.");
                    selected = groupGrid.selection.getSelected();
                    if(selected.length < 1)
                        return alert("Select a group to add to the family.");
                    for(var i = 0; i < membersStore.data.length; i++)
                    {
                        var matched = false;
                        mem_to_add = membersStore.data[i];
                        for(var j = 0; j < group.members.length; j++)
                        {
                            if(mem_to_add._id == group.members[j])
                                matched = true;
                        }
                        if(!matched)
                            group.members.push(mem_to_add._id);
                    }
                    console.log(group);
                    GroupGrid.update_pg(group);
                }
            }, "button_add_to_existing_pgf");

            //CREATE NEW PF BUTTON
            //REQUIRES A NAME
            var button_newPGF = new Button(
            {
                label: 'Commit',
                onClick: function()
                {
                    var groups = groupGrid.selection.getSelected();
                    if(dom.byId('txtBox_familyName').value.length < 1)
                    {
                        alert('A name is required for the new family.');
                        return;
                    }
                    if(groups < 1)
                    {
                        alert('You must select at least one group to form a family');
                        return;
                    }
                    FamilyGrid.analyzeNewPGF(groups);
                }
            }, "button_newPGF");

            //DELETE PF BUTTON
            var button_deletePGF = new Button(
                {
                    label: 'Delete', 
                    onClick: function()
                    {
                        FamilyGrid.removePGF(FamilyGrid.selected_families);
                    }
                }, "button_deletePGF");

            //DELETE PF BUTTON
            var button_clonePGF = new Button(
                {
                    label: 'Clone', 
                    onClick: function()
                    {
                        FamilyGrid.clonePGF(FamilyGrid.selected_families);
                    }
                }, "button_clonePGF");

            //DELETE PF BUTTON
            var button_deleteParameter = new Button(
                {
                    label: 'Delete', 
                    onClick: function()
                    {
                        FamilyViewerGrid.removeParameter(FamilyGrid.selected_families[0]);
                    }
                }, "button_deleteParameter");


            //COMMIT CHANGES PGF BUTTON
            var button_commitChanges = new Button(
                {
                    label: 'Commit Changes', 
                    onClick: function()
                    {
                        var selected = familyGrid.selection.getSelected();
                        var pgf = selected[0];
                        FamilyViewerGrid.analyzeChanges(pgf);
                    }
                }, "button_commitChanges");

            var button_recompute = new Button(
            {
                label: "Recompute Values",
                onClick: function()
                {
                    recompute_values(selectionMemStore);
                }
            }, "button_recompute");

            //Function that recomputes values for the given data store.
            var recompute_values = function(store)
            {
                var new_data = [];
                for(var i = 0; i < store.data.length; i++)
                {
                    var element = store.data[i];
                    console.log(element);
                    var v_temp = realizeValue(store.data, element.p_formula);
                    if(!v_temp == "")
                    {
                        element.p_value = v_temp;
                        new_data.push(element);
                    }
                }
                for(var i = 0;i < new_data.length; i++)
                {
                    var element = new_data[i];
                    store.remove(element.id);
                    store.add(element); 
                }
            }


            /****************************   HELPER FUNCTIONS  *********************************/


            //PARSE THE GIVEN DEFINITION STRING
            //RETURNS AN EMPTY STRING IF THE FORMULA IS EMPTY
            function realizeValue(data, formula)
            {
                //SPLIT THE STRING BY ';' AND STORE THE ELEMENTS IN AN ARRAY
                if(formula.length < 1)
                    return "";
                var formula_elements = formula.split(";");

                //AN ARRAY TO MAKE UP THE PARSED ELEMENTS OF THE OUTPUT STRING
                var output_elements = [];

                //STRING FOR FINAL OUTPUT
                var output = '';

                //IF THERE ARE NO PIs OR THE ARRAY IS NULL,
                //REPORT AN ERROR
                if(data.length < 1 || data == null)
                {
                    output = 'There was a problem acquiring the parameters';
                    console.log('Parse Error: ' + output);
                    return output;
                } 
                //WHILE ELEMENTS REMAIN
                while(formula_elements.length > 0)
                {
                    //FLAG FOR WHEN AN ELEMENT IS MATCHED
                    var not_found = true;

                    //GET THE NEXT ELEMENT FROM THE ARRAY
                    var element = formula_elements.shift();

                    if(element == "")
                        continue;

                    //FIND THE ELEMENTS FROM THE GROUP AND MATCH THEM TO THE ELEMENTS
                    for(var i = 0; i < data.length; i++)
                    {
                        if(!not_found) //IF ELEMENT HAS BEEN MATCHED, BREAK 
                            break;

                        //STORE CURRENT PARAMETER
                        var e = data[i];

                        //IF THE ELEMENT AND THE PARAMETER NAME MATCH, GET THE PARAMETERS VALUE
                        if(element == e.p_name)
                        {
                            v_temp = realizeValue(data, e.p_formula);
                            if(!v_temp == "")
                            {
                                e.p_value = v_temp;
                            }
                            if(/[\+\-\*\/]/.test(e.p_value))
                            {
                                try
                                {
                                    console.log(e.p_value);
                                    e.p_value = eval(e.p_value);
                                    e.p_value = e.p_value.toFixed(3); //ROUND TO 3 DECIMALS
                                    console.log(e.p_value);
                                }
                                catch(error)
                                {
                                    //if there's an error, ignore it and return the string as it was.
                                }
                            }
                            output_elements.push(e.p_value);
                            not_found = false;
                        }
                    }
                    //IF THE ELEMENT WAS NEVER MATCHED, IT'S PROBABLY A STRING OR AN OPERATOR, ADD IT TO THE OUTPUT
                    if(not_found)
                        output_elements.push(element);

                }
                //IF THERE ARE NO MORE ELEMENTS BUILD THE STRING AND RETURN IT
                if(formula_elements.length < 1)
                {
                    output = build_output_string(output_elements);
                    return output;
                }
                else //IF WE GET HERE AND HAVEN'T REPORTED THE STRING AND WE STILL HAVE ELEMENTS, THERE'S AN ERROR
                {
                    output = 'An unknown error occurred parsing the definition.';
                    return output;
                }
            }

            //BUILD THE OUTPUT STRING WITH THE GIVEN ARRAY OF STRINGS
            //RETURNS AN EMPTY STRING IF THE ELEMENTS ARE EMPTY
            function build_output_string(output_elements)
            {
                var output_string = '';
                if(output_elements.length < 1)
                    return "";
                for (var i = 0; i < output_elements.length; i++)
                {
                    output_string += output_elements[i];
                }

                output_elements = output_string.split("'");
                output_string = "";
                for(var i = 0; i < output_elements.length; i++)
                {
                    try
                    {
                        var e = output_elements[i];
                        e = eval(e);
                        e = e.toFixed(1);
                        var index = e.indexOf('.0');
                        if(index > -1)
                        {
                            e = e.substring(0, index);
                        }
                        output_elements[i] = e;
                    }
                    catch(error){}
                }
                for (var i = 0; i < output_elements.length; i++)
                {
                    output_string += output_elements[i];
                }

                if(/[\+\-\*\/]/.test(output_string))
                {
                    try
                    {
                        console.log(output_string);
                        output_string = eval(output_string);
                        output_string = output_string.toFixed(3); //ROUND TO 3 DECIMALS
                        console.log(output_string);
                    }
                    catch(error)
                    {
                        //if there's an error, ignore it and return the string as it was.
                    }
                }

                return output_string;
            }     

            //HELPER FUNCTION TO CHECK IF AN OBJECT POSSESSES ANY PROPERTIES
            function objectIsEmpty(map) 
            {
               for(var key in map) 
               {
                  if (map.hasOwnProperty(key)) 
                  {
                     return false;
                  }
               }
               return true;
            }

            //ON LOAD, GET THE FULL DB AND PUT IT IN A GLOBAL STORE   
            GetFullDbStore();
        });
    </script>
</head>

<!-- Layout -->
<body class="claro">
    <table width = '100%' border = "1">
        <col width = '47%'>
        <col width = '18%'>
        <col width = '35%'>
        <tr>
            <td style = "text-align: center; padding: 5px">
                <b>PGF Creator - Creates a New PGF</b>
                <div style = "text-align: right"><button id="button_add_to_existing_pgf"></button><button id = "button_newPGF"></button></div>
            </td>
            <td style = "text-align: center; vertical-align: top; padding: 5px">
                <b>PGF Lister - Lists All PGFs</b>
                <div style="text-align:right"><button id="button_clonePGF"></button>
                <button id="button_deletePGF"></button></div>
            </td>
            <td style = "text-align: center; vertical-align: top; padding: 5px">
                <b>PGF Viewer - Shows Selected PGF</b>
                <div style="text-align:right"><button id="button_deleteParameter"></button><button id = "button_commitChanges"></button></div>
            </td>
        </tr>
        <tr>
            <td valign = "top" style = "padding: 5px">
                <label for="txtBox_familyName">Name:</label><br>
                <input id="txtBox_familyName" data-dojo-type="dijit/form/TextBox" style ="width: 50%;"></input>
                <table width = '100%'>
                    <col width = '35%'>
                    <col width = '65%'>
                    <tr>
                        <td>
                            <div style = "padding: 5px" align='center'><b>Groups</b><div>
                        </td>
                        <td>
                            <table width="100%">
                                <col width="70%">
                                <col width="30%">
                                <tr>
                                    <td align = "center">
                                        <div style = "padding: 5px" align='center'><b>Preview</b><div>
                                    </td>
                                    <td align="right">
                                        <div style="text-align: right"><button  id="button_recompute"></button></div>
                                    </td>
                                </tr>
                            </table>
                        </td>
                    </tr>
                    <tr>
                        <td>
                            <div id="GroupGridDiv"></div>
                        </td>
                        <td>
                            <div id= "selectionGrid"></div>
                        </td>
                    </tr>
                </table>
            </td>
            <td valign = "top" style = "padding: 5px; text-align:right">
                <div id="FamilyGrid"></div>
            </td>
            <td valign = "top" style = "padding: 5px; text-align:right">
                <div id="FamilyViewerGrid"></div>
            </td>
        </tr>
        <tr>
            <table id='consoleTable' border = '1' width='100%'>
                <col width="70%">
                <col width="30%">
                <tr>
                    <td style = "padding: 10px">
                        <div id="serverResponse">Awaiting Action...</div>
                    </td>
                    <td>
                        <div id = "parseDisplay" style = "padding: 2px">Parsed Value: (Nothing Selected)</div>
                    </td>
                </tr>
            </table id='consoleTable'>
        </tr>
    </table>
</body>
</html>