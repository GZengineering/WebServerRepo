<!DOCTYPE html>
<!-- This code was written by Alex Stout for Goal Zero, LLC private use -->
<html lang='en' style= 'background-color:#00FFFF; padding: 0px 25px 25px'>
<head>
    <title>Parameter: Group</title>
    <h1 ALIGN = 'center' style = 'padding: 10px'> Parameter: Group </h1>


    <link rel="stylesheet" href="dojo_css">
    <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dijit/themes/claro/claro.css">
    <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dojox/grid/resources/claroGrid.css">
        
    <style type="text/css">@import "http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dojox/grid/resources/claroGrid.css";
        #FixedGridDiv 
        {
            height: 46em;
            width: 100%;
        }
        #CompGrid 
        {
            height: 46em;
            width: 100%;
        }
        #selectionGrid 
        {
            height: 55em;
            width: 100%;
        }
        #GroupGridDiv 
        {
            height: 55em;
            width: 100%;
        }
        .dojoxGridMasterView
        {
            font-size: 8pt;
        }
        .dojoxGridMasterHeader
        {
            font-size: 8pt;
        }
    </style>
    <script src="http://ajax.googleapis.com/ajax/libs/dojo/1.8.3/dojo/dojo.js" data-dojo-config="async: true, isDebug: true">
    </script>

    <!-- Dojo Execution -->
    <script>
    require(['dojo/_base/lang', 
        'dojox/grid/DataGrid' , 
        'dojo/data/ItemFileWriteStore',
        "dojo/_base/array",
        'dijit/registry',
        'dojo/_base/xhr', 
        'dojox/grid/_CheckBoxSelector',
        'dijit/form/RadioButton',
        'dijit/form/Select',
        "dijit/form/Button",
        'dojo/store/Observable',
        'dojo/store/Memory',
        'dojo/data/ObjectStore',
        'dojo/dom' , 
        'dojo/domReady!'],
      function(lang, DataGrid, ItemFileWriteStore, baseArray, registry, xhr, _CheckBoxSelector, RadioButton, Select, Button, Observable, Memory, ObjectStore, dom)
        {
            var fields = new Array();
            var has_loaded = false;

            /*  CREATE A DATA STORE TO CONTAIN ALL THE CONTENT OF THE SERVER  */
            var fullDbMemStore = new Memory({data: new Array()});
                fullDbMemStore = Observable(fullDbMemStore);
                var fullDataStore = new ObjectStore({
                    objectStore: fullDbMemStore
                });
            window.fullDbMemStore = fullDbMemStore; //MAKE IT GLOBAL

            /*  FUNCTION TO GET ALL THE DB DATA AND FILL THE DATA STORE  */
            GetFullDbStore = function()
            {
                xhr.get(
                {
                    url:'/global',
                    handleAs: 'json',
                    content:
                    {
                        action: 'getAll',
                        loaded: has_loaded = true,
                    },
                    load: function(response)
                    {
                        fullDbMemStore.data = response;
                        allocateStores();
                    },
                    error: function(error)
                    {
                        var msg = 'There was an error getting the db. Error: ' + error;
                        dom.byId("serverResponse").innerHTML = 'Response: ' + msg;
                        console.log(msg);
                    }
                });
            }

            /*  FILL THE SUBSTORES FOR THE PIS AND BUILD THE GRIDS  */
            function allocateStores()
            {
                /**  ALLOCATE GLOBAL FIXED PI MEMORY STORE  **/

                var fixedMemStore = new Memory({data: new Array()});
                fixedMemStore = Observable(fixedMemStore);
                var fixedDataStore = new ObjectStore({
                    objectStore: fixedMemStore
                });

                /**  ALLOCATE GLOBAL COMPUTED PI MEMORY STORE  **/

                var compMemStore = new Memory({data: new Array()});
                compMemStore = Observable(compMemStore);
                var compDataStore = new ObjectStore({
                    objectStore: compMemStore
                });

                //QUERY THE GLOBAL DB STORE FOR COMPUTED PIS

                /*  GLOBALIZE THE SUB-STORES  */
                window.fixedMemStore = fixedMemStore;
                window.fixedDataStore = fixedDataStore;
                window.compMemStore = compMemStore;
                window.compDataStore = compDataStore;

                /*  BUILD ALL THE GRIDS  */
                BuildGrids();
            }

            /*  BUILDS THE GRIDS USING THE COLLECTED AND ORGANIZED DATA  */
            function BuildGrids()
            {
                var groups = GroupGrid.getGroups();
                GroupGrid.buildGrid(groups);

                var fixed_PIs = FixedGrid.getFields();
                FixedGrid.buildGrid(fixed_PIs);

                var comp_PIs = CompGrid.getFields();
                CompGrid.buildGrid(comp_PIs);

                SelectionGrid.buildGrid(new Array());
                
                dom.byId('txtBox_groupName').value = '';
            }


            /********************************     Group Grid      *********************************/

            var GroupGrid = new Object();

            //GET AND RETURN THE GROUPS FROM THE STORE
            GroupGrid.getGroups = function()
            {
                var groups = fullDbMemStore.query({type: 'param_group'});
                return groups;
            }

            //BUILD THE DOJO GRID WITH THE GIVEN ARRAY OF GROUPS
            GroupGrid.buildGrid = function(groups)
            {
                //DEFINE THE LAYOUT
                var layout = [[
                  {'name': '#', 'field': 'id', 'width': '5%'},
                  {'name': 'Group', 'field': 'pg_name', 'width': '70%'},
                  {'name': 'Type', 'field': 'pg_type', 'width': '25%'}
                ]];

                //ALLOCATE THE STORE
                var GroupMemStore = new Memory({data: new Array()}); //set up the store
                GroupMemStore = Observable(GroupMemStore);
                var GroupDataStore = new ObjectStore({
                    objectStore: GroupMemStore
                });
                
                //Fill the store with the retrieved DB data
                for(var i = 0; i < groups.length; i++)
                {
                    GroupMemStore.put(lang.mixin(
                        { id: i }, 
                        groups[i]
                    ));
                }

                /*create a new grid*/
                var grid = new DataGrid({
                    store: GroupDataStore,
                    structure: layout}, 'GroupGridDiv');
                grid.startup(); //RENDER

                dojo.connect(GroupMemStore, 'notify', function(){grid._refresh()});
                

                //UPDATE THE GROUP SELECTION AND DISPLAY IT IN THE RESPONSE DIV
                function reportSelection(node)
                {
                    //STORE THE SELECTED ITEMS
                    var groups = this.selection.getSelected();
                    GroupGrid.selected_groups = groups;

                    //GET THE PIs OF THE SELECTED GROUP & REBUILD THE SELECTION STORE
                    var pis = GroupGrid.getFieldsOfGroups(groups);
                    SelectionGrid.rebuildStore(pis);

                    /*  DISPLAY WHAT'S SELECTED IN THE PROMPT  */
                    if(groups.length < 1)
                        return;

                    var msg = "You have selected " + ((groups.length > 1) ? " ": " ");
                    //FOR EACH PG IN GROUPS, GET THE PG_NAME AND PUT IT IN AN ARRAY 
                    var pg_names = [];
                    for(var i = 0; i < groups.length; i++)
                        pg_names.push(groups[i].pg_name);

                    //UPDATE RESPONSE DIV
                    node.innerHTML = msg + pg_names.join(", ");
                }
                
                //On selection change, call reportSelection() and pass in the response dom
                grid.on("SelectionChanged", 
                    lang.hitch(grid, reportSelection, dom.byId("serverResponse")), true);

                //make the following properties global
                window.GroupData = GroupMemStore.data;
                window.groupGrid = grid;
                window.GroupDataStore = GroupDataStore;
                window.GroupMemStore = GroupMemStore;
            }


            GroupGrid.new_pg = function()
            {
                var pg_type = 'report';
                if(radio_product.checked)
                    pg_type = 'product';

                var pis = FixedGrid.selected_fields.concat(CompGrid.selected_fields);
                console.log(pis);

                var pi_ids = [];
                for(var i = 0; i < pis.length; i++)
                {
                    pi_ids.push(pis[i]._id)
                }

                var pg = {
                    pg_name: dom.byId('txtBox_groupName').value,
                    pg_type: pg_type,
                    pi_ids: pi_ids
                };
                //send request to create a new PG
                xhr.get(
                {
                    url:"/group", 
                    handleAs: 'json',
                    content: 
                    {
                        action: 'new_pg',
                        pg: JSON.stringify(pg),
                        loaded: has_loaded=true,
                    },
                    load:function(response)
                    {
                        dom.byId("serverResponse").innerHTML = "Response from server: " + pg.pg_name + " successfully added.";
                        ClearTextFields();
                        add_to_group_store(response);
                    },
                    error:function(error)
                    {
                        console.log("There was an error: \n"+error);
                        dom.byId("serverResponse").innerHTML = "Response from server: " + error;
                    }
                });

                add_to_group_store = function(pg)
                {
                    var _pg = new Object(pg);
                    var index = GroupMemStore.data.length;
                    GroupMemStore.put(lang.mixin(
                        {id: index}, 
                        _pg
                    )); 
                }
            }

            //Removes an entire group from the database given the id of the row
            //of the selected group
            GroupGrid.removePG = function(selected)
            {
                if(!selected)
                    return;

                if(!selected[0]){ return alert('error deleting '+selected[0].pg_name+' from Parameter Grid'); }
                if(!confirm("Are you sure you want to delete \'" + selected[0].pg_name +"\'?"))
                    return;
                else
                {
                    xhr.get(
                    {
                        url:"/group",
                        content: 
                        {
                            action: 'remove_pg',
                            pg: JSON.stringify(selected[0]),
                            loaded: has_loaded=true,
                        },
                        load:function(response)
                        {
                            dom.byId("serverResponse").innerHTML = "Response from server: " + response;
                            remove_from_Group_store();
                        },
                        error:function(error)
                        {
                            console.log("There was an error: \n"+error);
                            dom.byId("serverResponse").innerHTML = "Response from server: " + error;
                        }
                    });
                }

                remove_from_Group_store = function()
                {
                    GroupMemStore.remove(selected[0].id);
                }
            }


            //GETS AND RETURNS ALL THE PIs OF THE GIVEN PGs
            GroupGrid.getFieldsOfGroups = function(pgs)
            {
                //IF THE GIVEN ARRAY IS EMPTY, RETURN AN EMPTY ARRAY
                if(pgs.length < 1)
                {
                    return new Array();
                }

                //CREATE AN ARRAY TO STORE REALIZED PIs
                var pis = [];

                //FOR EACH GROUP IN THE GIVEN PGs, MATCH THE PI IDs TO IDs IN THE STORE
                //IF A MATCH IS FOUND, ADD IT TO THE STORE AND MOVE TO THE NEXT PI
                for(var h = 0; h < pgs.length; h++)
                {   
                    //STORE THE CURRENT PG
                    var pg = pgs[h];

                    //IF THE PG IS NULL, BAIL
                    if(!pg)
                        return;

                    for(var i = 0; i < pg.pi_ids.length; i++)
                    {
                        //FLAGS IF A MATCH IS FOUND
                        var matched = false;
                        for(var j = 0; j < fixedMemStore.data.length; j++)
                        {
                            if(matched)
                                break;
                            //TRY TO MATCH THE CURRENT PI ID TO AN ID IN THE STORE
                            if(pg.pi_ids[i] == fixedMemStore.data[j]._id)
                            {
                                //IF THERE'S A MATCH, PUSH THE PI OBJECT TO THE ARRAY
                                pis.push(fixedMemStore.data[j]);
                                matched = true;
                            }
                        }
                        if(!matched)
                        {
                            //IF NO MATCH IS FOUND FOR THE CURRENT PI_ID, CHECK THE COMPUTED PI STORE
                            for(var j = 0; j < compMemStore.data.length; j++)
                            {
                                if(matched)
                                    break;
                                if(pg.pi_ids[i] == compMemStore.data[j]._id)
                                {
                                    pis.push(compMemStore.data[j]);
                                    matched = true;
                                }
                            }
                        }
                    }
                }
                return pis;
            }

            /********************************      End Group Grid      ********************************/

            /********************************  **  **  **  **  **  **  ********************************/

            /********************************       Fixed PI Grid      ********************************/

            //The FixedGrid is the grid that displays all the available fields from the database.
            var FixedGrid = new Object();

            //GET THE FIXED PIs FROM THE GLOBAL STORE
            FixedGrid.getFields = function()
            {
                var fixed_PIs = fullDbMemStore.query({pi_type: 'fixed'}); 
                return fixed_PIs;
            }

            //Build the Dojo Grid with the 
            FixedGrid.buildGrid = function(fields)
            {
                var layout = [{type: 'dojox.grid._CheckBoxSelector'},[
                  {'name': '#', 'field': 'id', 'width': '5%'},
                  {'name': 'Parameter', 'field': 'pi_name', 'width': '45%'},
                  {'name': 'Value', 'field': 'pi_value', 'width': '20%'},
                  {'name': 'Unit', 'field': 'pi_unit', 'width': '20%'}
                ]];


                //Fill the store with the retrieved DB data
                for(var i = 0; i < fields.length; i++)
                {
                    fixedMemStore.put(lang.mixin(
                        { id: i }, 
                        fields[i]
                    ));
                }

                /*create a new grid*/
                var grid = new DataGrid({
                    store: fixedDataStore,
                    structure: layout}, 'FixedGridDiv');
                grid.startup(); //RENDER

                dojo.connect(fixedMemStore, 'notify', function(){grid._refresh()});

                //This function reports what fields are selected for the current working group
                function reportSelection(node)
                {
                    var items = this.selection.getSelected();
                    FixedGrid.selected_fields = items;
                    if(FixedGrid.selected_fields.length > 0)
                    {
                        var msg = "You have selected " + ((FixedGrid.selected_fields.length > 1) ? " ": " ");
                    }
                    else
                        return;
                    
                    var pi_names = baseArray.map(items, function(item)
                    {
                        return item.pi_name;
                    }, this);
                    node.innerHTML = msg + pi_names.join(", ");
                }
                
                //On selection change, call reportSelection() and pass in the response dom
                grid.on("SelectionChanged", 
                    lang.hitch(grid, reportSelection, dom.byId("serverResponse")), true);


                //make the following properties global
                window.fixedData = fixedMemStore.data;
                window.fixedGrid = grid;
            }

            /********************************     End of Fixed PI Grid      *********************************/


            /********************************     Computed PI Grid      *********************************/

            //The containing object for the Computed Grid
            var CompGrid = new Object();

            //GET THE COMP PIs FROM THE GLOBAL STORE
            CompGrid.getFields = function()
            {
                var comp_PIs = fullDbMemStore.query({pi_type: 'computed'});
                return comp_PIs;
            }


            //Build the Dojo Grid with the 
            CompGrid.buildGrid = function(fields)
            {
                /*set up layout*/
                var layout = [{type: 'dojox.grid._CheckBoxSelector'},[
                  {'name': '#', 'field': 'id', 'width': '3%'},
                  {'name': 'Name', 'field': 'pi_name', 'width': '22%'},
                  {'name': 'Definition (truncated)', 'field': 'pi_def_trunc', 'width': '65%'}
                ]];


                //Fill the store with the retrieved DB data
                for(var i = 0; i < fields.length; i++)
                {
                    compMemStore.put(lang.mixin(
                        { id: i }, 
                        fields[i] 
                    ));
                    //truncate the definitions
                    var def = compMemStore.data[i].pi_def;
                    compMemStore.data[i].pi_def_trunc = def.substring(0, 20) + ' ... ' + def.substring(def.length-20, def.length);
                }

                /*create a new grid*/
                var grid = new DataGrid({
                    store: compDataStore,
                    structure: layout}, 'CompGrid');

                /*Call startup() to render the grid*/
                grid.startup();
                dojo.connect(compMemStore, 'notify', function(){grid._refresh();});

                //This function reports what fields are selected for the current working group
                function reportSelection(node)
                    {
                        var items = this.selection.getSelected();
                        CompGrid.selected_fields = items;
                        if(CompGrid.selected_fields.length > 0)
                        {
                            var msg = "You have selected " + ((CompGrid.selected_fields.length > 1) ? " ": " ");
                        }
                        else
                            return;

                        var pi_names = baseArray.map(items, function(item)
                        {
                            return item.pi_name;
                        }, this);
                        node.innerHTML = msg + pi_names.join(", ");
                    }

                //CONNECT THE SELECTION_CHANGED EVENT TO THE REPORT SELECTION METHOD
                grid.on("SelectionChanged", 
                    lang.hitch(grid, reportSelection, dom.byId("serverResponse")), true);

                /*  REGISTER THE MOUSE_OVER EVENT TO DISPLAY THE DEFINITION IN A DIV ELEMENT  */
                dojo.connect(grid, "onRowMouseOver", function(e)
                {
                    //GET THE DEFINITION FROM THE ITEM IN THE GRID BEING HOVERED OVER
                    var def_display = grid.store.getValue(grid.getItem(e.rowIndex), 'pi_def');
                    if(!def_display) //IF THERE ISN'T A VALUE, THEN ITS TYPE IS FIXED
                        def_display = 'Not defined for fixed parameters';
                    //UPDATE THE DIV ELEMENT FOR THE USER
                    dom.byId("defDisplay").innerHTML = "Definition of highlighted Parameter: " + def_display;
                });


                /*  GLOBALIZE THE GRID PROPERTIES  */
                window.compData = compMemStore.data;
                window.compGrid = grid;
            }

            /********************************     End of Computed PI Grid      *********************************/


            /*******************************    BEGIN SELECTION GRID    ******************************/

            //OBJECT TO ASSOCIATE ALL FUNCTIONS AND PROPERTIES OF THE SELECTION GRID
            var SelectionGrid = new Object();
            
            /*  BUILD THE GRID GIVEN THE PIs AS A PARAMETER  */
            SelectionGrid.buildGrid = function(pis)
            {
                /*  DEFINE LAYOUT  */
                var layout = [[
                  {'name': '#', 'field': 'id', 'width': '5%'},
                  {'name': 'Parameters', 'field': 'pi_name', 'width': '47%'},
                  {'name': 'type', 'field': 'pi_type_display', 'width':'8%'},
                  {'name': 'Value', 'field': 'pi_value_display', 'width':'25%'},
                  {'name': 'Unit', 'field': 'pi_unit_display', 'width':'15%'},
                ]];

                /*  SET UP DATA STORE  */
                var selectionMemStore = new Memory({data: new Array()});
                selectionMemStore = Observable(selectionMemStore);
                var selectionDataStore = new ObjectStore({
                    objectStore: selectionMemStore
                });

                // /*  FILL THE STORE WITH THE NEW DATA */
                var rowCount = 0;
                for(var i = 0; i < pis.length; i++)
                {
                    console.log(pis[i]);
                    var row = {};
                    var pi = pis[i];
                    row.id = rowCount++; //reset id's
                    row.pi_name = pi.pi_name;
                    row.pi_def = pi.pi_def;
                    row.pi_value_display = pi.pi_value;
                    row.pi_unit_display = pi.pi_unit;
                    if(pi.pi_type == 'computed')
                    {
                        row.pi_value_display = '...';
                        row.pi_unit_display = '...';
                    }
                    row.pi_type_display = pi.pi_type.substring(0,1);
                    selectionMemStore.put(row);
                }

                /*  CREATE THE DOJO GRID AND RENDER IT  */
                var selectionGrid = new DataGrid({
                    store: selectionDataStore,
                    structure: layout,
                    autoHeigth: true}, "selectionGrid");
                selectionGrid.startup();

                /*  REGISTER THE MOUSE_OVER EVENT TO DISPLAY THE DEFINITION IN A DIV ELEMENT  */
                dojo.connect(selectionGrid, "onRowMouseOver", function(e)
                {
                    //GET THE DEFINITION FROM THE ITEM IN THE GRID BEING HOVERED OVER
                    var def_display = selectionGrid.store.getValue(selectionGrid.getItem(e.rowIndex), 'pi_def');
                    if(!def_display) //IF THERE ISN'T A VALUE, THEN ITS TYPE IS FIXED
                        def_display = 'Not defined for fixed parameters';
                    //UPDATE THE DIV ELEMENT FOR THE USER
                    dom.byId("defDisplay").innerHTML = "Definition of highlighted Parameter: " + def_display;

                    //GET THE DEFINITION FROM THE ITEM IN THE GRID BEING HOVERED OVER
                    var definition = selectionGrid.store.getValue(selectionGrid.getItem(e.rowIndex), 'pi_def');
                    var parse_display = '';
                    if(!definition) //IF THERE ISN'T A VALUE, THEN ITS TYPE IS FIXED
                        parse_display = 'Not defined for fixed parameters';
                    else
                        parse_display = parseDefinitionFieldToOutput(definition);

                    //UPDATE THE DIV ELEMENT FOR THE USER
                    dom.byId("parseDisplay").innerHTML = "Parsed Definition: " + parse_display;
                });

                /*  GLOBALIZE GRID PROPERTIES  */
                window.selectionData = selectionMemStore.data;
                window.selectionGrid = selectionGrid;
                window.selectionDataStore = selectionDataStore;
                window.selectionMemStore = selectionMemStore;
            }

            /*  ON SELECTION CHANGE OF THE GROUP GRID, THE SELECTION GRID STORE IS REPOPULATED  */
            SelectionGrid.rebuildStore = function(pis)
            {
                //IF THERE ARE NO PIs, GET OUT
                if(!pis)
                    return;

                //CLEAR THE STORE
                selectionMemStore.data = new Array();

                // /*  FILL THE STORE WITH THE NEW DATA */
                var rowCount = 0;
                for(var i = 0; i < pis.length; i++)
                {
                    console.log(pis[i]);
                    var row = {};
                    var pi = pis[i];
                    row.id = rowCount++;
                    row.pi_name = pi.pi_name;
                    row.pi_def = pi.pi_def;
                    row.pi_value_display = pi.pi_value;
                    row.pi_unit_display = pi.pi_unit;
                    if(pi.pi_type == 'computed')
                    {
                        row.pi_value_display = '...';
                        row.pi_unit_display = '...';
                    }
                    row.pi_type_display = pi.pi_type.substring(0,1);
                    selectionMemStore.put(row);
                }
                console.log(selectionGrid.store);
                selectionGrid._refresh();
            }

            //PARSE THE GIVEN DEFINITION STRING
            function parseDefinitionFieldToOutput(definition)
            {
                //SPLIT THE STRING BY ';' AND STORE THE ELEMENTS IN AN ARRAY
                var def_elements = definition.split(";");

                //AN ARRAY TO MAKE UP THE PARSED ELEMENTS OF THE OUTPUT STRING
                var output_elements = [];

                //QUERY THE STORE FOR ALL PIs
                var pis = fullDbMemStore.query({type: 'param_individual'});

                //STRING FOR FINAL OUTPUT
                var output = '';

                //IF THERE ARE NO PIs OR THE ARRAY IS NULL,
                //REPORT AN ERROR
                if(pis.length < 1 || pis == null)
                {
                    output = 'There was a problem acquiring the parameters';
                    console.log('Parse Error: ' + output);
                    return output;
                } 
                //WHILE ELEMENTS REMAIN
                while(def_elements.length > 0)
                {
                    //FLAG FOR WHEN AN ELEMENT IS MATCHED
                    var not_found = true;
                    //TEMP VARIABLE TO STORE A GRABBED PROPERTY
                    var temp_property;

                    //GET THE NEXT ELEMENT FROM THE ARRAY
                    var element = def_elements.shift();

                    //TRY TO PARSE THE ELEMENT TO A JSON OBJECT
                    try
                    {
                        element = eval("("+element+")");
                    }
                    catch(error) //CATCH ANY ERRORS
                    {
                        //IF THE ERROR IS A SYNTAX ERROR, THAT'S NORMAL,
                        //ADD THE ELEMENT TO THE OUTPUT AND CONTINUE
                        if(error = SyntaxError)
                        {
                            output_elements = add_element(output_elements, element);
                            continue;
                        }
                        else //OTHERWISE, REPORT THE ERROR
                        {
                            console.log('Error:' + error);
                        }
                    }

                    //IF THE ELEMENT HAS AN 'f' PROPERTY
                    if(element.f != null)
                    {
                        //FOR EVERY PI, TRY TO MATCH THE 'f' PROPERTY TO A PI NAME
                        for(var i = 0; i < pis.length; i++)
                        {
                            //IF A MATCH IS FOUND, CHECK WHICH PROPERTY WE'RE LOOKING FOR
                            //AND GET THE APPROPRIATE VALUE FROM THE MATCHED PI
                            if(element.f == pis[i].pi_name)
                            {
                                if(element.p == 'value')
                                    temp_property = pis[i].pi_value;
                                else
                                    temp_property = pis[i].pi_unit;
                                //ADD THE PROPERTY TO THE OUTPUT
                                output_elements = add_element(output_elements, temp_property);

                                //FLAG THAT WE FOUND A MATCH AND BREAK THE LOOP
                                not_found = false;
                                break;
                            }
                        }
                        //IF WE GET HERE AND THERE'S NO MATCH, IT DOESN'T EXIST IN THE STORE
                        //ADD A 'NO MATCH' TO THE OUTPUT
                        if(not_found)
                        {
                            output_elements = add_element(output_elements, '(No Match for: ' + element.f + ')');
                        }
                    }
                    else //IF IT IS NULL, ADD IT ANYWAY SO THE USER CAN SEE IT
                    {
                        output_elements = add_element(output_elements, element);
                    }
                }
                //IF THERE ARE NO MORE ELEMENTS BUILD THE STRING AND RETURN IT
                if(def_elements.length < 1)
                {
                    output = build_output_string(output_elements);
                    return output;
                }
                else //IF WE GET HERE AND HAVEN'T REPORTED THE STRING AND WE STILL HAVE ELEMENTS, THERE'S AN ERROR
                {
                    output = 'An unknown error occurred parsing the definition.';
                    console.log(output);
                    alert(output);
                    return output;
                }
            }

            //ADD THE GIVEN ELEMENT TO THE GIVEN OUTPUT ARRAY
            function add_element(output_elements, element)
            {
                output_elements.push(element);
                return output_elements;       
            }

            //BUILD THE OUTPUT STRING WITH THE GIVEN ARRAY OF STRINGS
            function build_output_string(output_elements)
            {
                var output_string = '';
                for (var i = 0; i < output_elements.length; i++)
                    output_string += output_elements[i];
                return output_string
            }

            /********************************     End Selection Grid      *********************************/


            /********************************     Text Boxes, buttons, etc.      *********************************/


            //Group Name Textbox
            var txtBox_groupName = registry.byId("txtBox_groupName");

            var radio_product= new RadioButton(
                {
                    checked: true,
                    value: "product",
                    name: "pg-type",

                }, "radio_product");


            var radio_report = new RadioButton(
                {
                    checked: false,
                    value: "report",
                    name: "pg-type",
                }, "radio_report");


            //Confirm selection button for new group
            //require a name for the group
            var button_newPG = new Button(
            {
                label: 'Confirm',
                onClick: function()
                {
                    if(dom.byId('txtBox_groupName').value.length < 1)
                        alert('A name is required for the new group.');
                    else
                        GroupGrid.new_pg();
                }
            }, "button_newPG");


            //button to delete a selected group
            var button_delete_group = new Button(
                {
                    label: 'Delete', 
                    onClick: function()
                    {
                        GroupGrid.removePG(GroupGrid.selected_groups);
                    }
                }, "button_delete_group");

        //CLEAR TEXT FIELDS AND GRID SELECTIONS
        function ClearTextFields()
        {
            dom.byId('txtBox_groupName').value = '';
            fixedGrid.selection.clear();
            compGrid.selection.clear();
        }

        GetFullDbStore();
        });
</script>
</head>

<!-- Layout -->
<body class="claro">
    <table width = '100%' border = "1">
        <col width = "45%">
        <col width = "18%">
        <col width = "35%">
        <tr> <!-- Labels -->
            <td style = "text-align: center; padding: 5px">
                <b>PG creator - Creates a New PG</b>
                <div style="text-align: right"><button id = "button_newPG"></button></div>
            </td>
            <td style = "text-align: center; vertical-align: top; padding: 5px">
                <b>PG lister - Lists All PGs</b>
                <div style="text-align: right"><button id="button_delete_group"></button></div>
            </td>
            <td style = "text-align: center; vertical-align: top; padding: 5px">
                <b>PG Viewer - Shows Selected PG</b>
            </td>
        </tr>
        <tr> <!-- Grids -->
            <td valign = "top" style = "padding: 5px">
                <div style = "padding: 2px">
                <input id = "radio_product"><label for = "radio_product">Product</label></div>
                <div style = "padding: 2px">
                <input id = "radio_report"><label for = "radio_report">Report</label><br><br></div>
                <label for="txtBox_groupName" style = "padding: 5px">Name:</label><br>  
                <input id="txtBox_groupName" data-dojo-type="dijit/form/TextBox" style ="width: 50%;"></input>
                <br><br>
                <table width='100%'>
                    <col width='35%'>
                    <col width='65%'>
                    <tr>
                        <td style = 'padding: 2px'>
                        <div style = "padding 2px" align='center'><b>Fixed Parameters</b></div>
                            <div id="FixedGridDiv"></div>
                        </td>
                        <td style = 'padding: 2px'>
                        <div style = "padding 2px" align='center'><b>Computed Parameters</b></div>
                            <div id="CompGrid"></div>
                        </td>
                    </tr>
                </table>
            </td>
            <td valign = "top" style = "padding: 5px; text-align:right">
                <div id="GroupGridDiv"></div>
            </td>
            <td valign ="top" style = "padding: 5px">
                <div id="selectionGrid"></div>
            </td>
        </tr>
        <tr>
            <td style = "padding: 10px">
                <div id="serverResponse">Awaiting Action...</div>
            </td>
            <td colspan = '2'>
                <div id="defDisplay" style = "padding: 2px">Definition of highlighted Parameter: (Nothing highlighted)</div>
                <div id="parseDisplay" style = "padding: 2px">Parsed Definition: (Nothing highlighted)</div>
            </td>
        </tr>
    </table>
</body>
</html>